# 算法和数据结构体系学习



# 一、时间复杂度、空间复杂度、对数器和二分法

## 1.1评估算法优劣的核心指标

时间复杂度、空间复杂度



## 1.2选择排序、冒泡排序、插入排序

### 选择排序

每轮找到最小的值放在最左边的位置上

```java
public static void selectionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1  找到最小值，在哪，放到0位置上
		// 1 ~ n-1  找到最小值，在哪，放到1 位置上
		// 2 ~ n-1  找到最小值，在哪，放到2 位置上
		for (int i = 0; i < arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arr.length; j++) { // i ~ N-1 上找最小值的下标 
				minIndex = arr[j] < arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}
```

### 冒泡排序

每遇到一个比自己大的就和它互换位置，一路换到头

```java
public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 0 ~ N-1 遍历，把0 ~ N-1的最大值换到N-1位置上
		// 0 ~ N-2 遍历，把0 ~ N-2的最大值换到N-2位置上
		// 0 ~ N-3 遍历，把0 ~ N-3的最大值换到N-3位置上
		for (int e = arr.length - 1; e > 0; e--) { // 0 ~ e
			for (int i = 0; i < e; i++) {
				if (arr[i] > arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}
```

### 插入排序

```java
public static void insertionSort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		// 每次循环把i上的数放到它应该在的位置，使i前面都有序
		for (int i = 1; i < arr.length; i++) { // 0 ~ i 做到有序
			for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {// 只要j比j后面的数大就调换顺序
				swap(arr, j, j + 1);
			}
		}
	}
```

## 1.3最优解

## 1.4对数器

用于自己测试算法是否正确

### 工具方法

#### 生成随机数组

```java
public static int[] generateRandomArray(int maxSize, int maxValue) {
		// Math.random() -> [0,1) 所有的小数，等概率返回一个
		// Math.random() * N -> [0,N) 所有小数，等概率返回一个
		// (int)(Math.random() * N) -> [0,N-1] 所有的整数，等概率返回一个
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; // 长度随机
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}
```

#### 比较数组是否一致

```java
public static boolean isEqual(int[] arr1, int[] arr2) {
		if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
			return false;
		}
		if (arr1 == null && arr2 == null) {
			return true;
		}
		if (arr1.length != arr2.length) {
			return false;
		}
		for (int i = 0; i < arr1.length; i++) {
			if (arr1[i] != arr2[i]) {
				return false;
			}
		}
		return true;
	}
```

#### 复制数组

```java
public static int[] copyArray(int[] arr) {
		if (arr == null) {
			return null;
		}
		int[] res = new int[arr.length];
		for (int i = 0; i < arr.length; i++) {
			res[i] = arr[i];
		}
		return res;
	}
```

#### 打印数组

```java
public static void printArray(int[] arr) {
		if (arr == null) {
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.print(arr[i] + " ");
		}
		System.out.println();
	}
```



### 对数器测试方法

以前一个插入排序为例

```java
public static void main(String[] args) {
		int testTime = 500000;// 测试次数
		int maxSize = 10;// 随机数组最大size
		int maxValue = 100;// 随机数组中value的最大值
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);// 每轮都随机生成一个数组
			int[] arr1 = copyArray(arr);// 复制
			int[] arr2 = copyArray(arr);// 复制
			insertionSort(arr1);// 用自己的方法排序
			Arrays.sort(arr2)// 用官方方法排序
			if (!isEqual(arr1, arr2)) {// 如果不相等
                printArray(arr);// 打印arr
				printArray(arr1);// 打印arr1
				printArray(arr2);// 打印arr2
				succeed = false;
				System.out.println();
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
        // 测试成功，展示一个
		int[] arr = generateRandomArray(maxSize, maxValue);
		printArray(arr);
		insertionSort(arr);
		printArray(arr);
	}
```

因此后续可以自己这样测试代码：

```java
public static void main(String[] args) {
		int testTime = 500000;// 测试次数
		int maxSize = 10;// 定义随机测试需要用到的数据
		int maxValue = 100;
		// 。。。
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			// 。。。
			// 进行测试
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
	}
```

## 1.5二分法

### (1)使用二分法在有序数组中找到num

```
public static boolean exist(int[] sortedArr, int num) {
		if (sortedArr == null || sortedArr.length == 0) {
			return false;
		}
		int L = 0;
		int R = sortedArr.length - 1;
		int mid = 0;
		// L..R
		while (L < R) { // L..R 至少两个数的时候
			mid = L + ((R - L) >> 1);
			if (sortedArr[mid] == num) {
				return true;
			} else if (sortedArr[mid] > num) {
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return sortedArr[L] == num;
	}
```

#### 工具方法

##### 生成随机值

```
public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
		}
		return arr;
	}
```

##### 测试数组中有没有指定num

```
public static boolean isExistNumInArr(int[] sortedArr, int num) {
        for(int cur : sortedArr) {
            if(cur == num) {
                return true;
            }
        }
        return false;
    }
```

#### 使用对数器验证

```
public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 10;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);
			Arrays.sort(arr);
			int value = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
			if (isExistNumInArr(arr, value) != exist(arr, value)) {
				succeed = false;
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
	}
```

### (2)使用二分法在有序数组中找到>=num最左的位置

```
public static int nearestIndex(int[] arr, int value) {
		int L = 0;
		int R = arr.length - 1;
		int index = -1; // 记录最左的对号
		while (L <= R) { // 至少一个数的时候
			int mid = L + ((R - L) >> 1);
			if (arr[mid] >= value) {
				index = mid;
				R = mid - 1;
			} else {
				L = mid + 1;
			}
		}
		return index;
	}
```

#### 工具方法

##### 找到数组中num的下标并返回

```
public static int numIndexInArr(int[] arr, int value) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= value) {
                return i;
            }
        }
        return -1;
    }
```

#### 使用对数器验证

```java
public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 10;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);
			Arrays.sort(arr);
			int value = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
			if (numIndexInArr(arr, value) != nearestIndex(arr, value)) {
				printArray(arr);
				System.out.println(value);
				System.out.println(numIndexInArr(arr, value));
				System.out.println(nearestIndex(arr, value));
				succeed = false;
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
	}
```

### (3)使用二分法在有序数组中找到<=num最右的位置

```java
public static int nearestIndex(int[] arr, int value) {
		int L = 0;
		int R = arr.length - 1;
		int index = -1; // 记录最右的对号
		while (L <= R) {
			int mid = L + ((R - L) >> 1);
			if (arr[mid] <= value) {
				index = mid;
				L = mid + 1;
			} else {
				R = mid - 1;
			}
		}
		return index;
	}
```

#### 使用对数器验证

```java
public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 10;
		int maxValue = 100;
		boolean succeed = true;
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);
			Arrays.sort(arr);
			int value = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
			if (numIndexInArr(arr, value) != nearestIndex(arr, value)) {
				printArray(arr);
				System.out.println(value);
				System.out.println(numIndexInArr(arr, value));
				System.out.println(nearestIndex(arr, value));
				succeed = false;
				break;
			}
		}
		System.out.println(succeed ? "Nice!" : "Fucking fucked!");
	}
```

### (4)使用二分法在无序数组，已知任何两个相邻的数都不相等，找到任意一个极值点并返回

若f(a)是函数f(x)的极大值或极小值，则a为函数f(x)的*极值点*，极大值点与极小值点统称为*极值点*。

```java
public static int getLessIndex(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1;
		}
		if (arr.length == 1 || arr[0] < arr[1]) {
			return 0;
		}
		if (arr[arr.length - 1] < arr[arr.length - 2]) {
			return arr.length - 1;
		}
		int left = 1;
		int right = arr.length - 2;
		int mid = 0;
		while (left < right) {
			mid = (left + right) / 2;
			if (arr[mid] > arr[mid - 1]) {
				right = mid - 1;
			} else if (arr[mid] > arr[mid + 1]) {
				left = mid + 1;
			} else {
				return mid;
			}
		}
		return left;
	}
```



#### 工具方法

```java
// 验证得到的结果，是不是局部最小
	public static boolean isRight(int[] arr, int index) {
		if (arr.length <= 1) {
			return true;
		}
		if (index == 0) {
			return arr[index] < arr[index + 1];
		}
		if (index == arr.length - 1) {
			return arr[index] < arr[index - 1];
		}
		return arr[index] < arr[index - 1] && arr[index] < arr[index + 1];
	}

	// 为了测试
	// 生成相邻不相等的数组
	public static int[] generateRandomArray(int maxSize, int maxValue) {
		int[] arr = new int[(int) (Math.random() * maxSize) + 1];
		arr[0] = (int) (Math.random() * maxValue) - (int) (Math.random() * maxValue);
		for (int i = 1; i < arr.length; i++) {
			do {
				arr[i] = (int) (Math.random() * maxValue) - (int) (Math.random() * maxValue);
			} while (arr[i] == arr[i - 1]);
		}
		return arr;
	}
```



#### 使用对数器验证

```java
// 为了测试
	public static void main(String[] args) {
		int testTime = 500000;
		int maxSize = 30;
		int maxValue = 100;
		System.out.println("测试开始");
		for (int i = 0; i < testTime; i++) {
			int[] arr = generateRandomArray(maxSize, maxValue);
			int ans = getLessIndex(arr);
			if (!isRight(arr, ans)) {
				System.out.println("出错了！");
				break;
			}
		}
		System.out.println("测试结束");
	}
```





# 二、异或运算、进一步认识对数器的重要性

## 2.1异或运算的性质

异或运算，相同为0，不同为1

因此有以下三大性质

1. 0 ^ N = N：任意数和0异或等于该数本身
2. N ^ N = 0：相等的数异或等于0
3. A ^ B = B ^ A：满足交换律

## 2.2异或运算的题目

#### 不用额外变量交换两个数的值

```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

#### CODE01_不用额外变量交换数组中两个数的值

```java
public static void swap (int[] arr, int i, int j) {
		// 如果i=j，会导致arr[i]和arr[j]都等于0
		arr[i]  = arr[i] ^ arr[j];
		arr[j]  = arr[i] ^ arr[j];
		arr[i]  = arr[i] ^ arr[j];
	}
```

#### CODE02_在数组中找到出现次数为奇数的数

##### 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，找到并打印这种数 

因为相同的数异或等于0，因此所有数异或在一起，剩下的就是奇数的那个数

```java
public static void printOddTimesNum1(int[] arr) {
		int eor = 0;
		for (int i = 0; i < arr.length; i++) {
			eor ^= arr[i];
		}
		System.out.println(eor);
	}
```

##### 怎么把一个int类型的数，提取出二进制中最右侧的1来

将该数与该数的相反数进行与运算即可

与运算&：全1为1，有0为0

负数为取反加一

例子：

a : 	  	01001001000

~a : 		10110110111

~a+1:  	10110111000

a&~a+1: 00000001000

```java
int rightOne = a & (-a);
```

##### 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，找到并打印这种数

将所有数异或起来，剩下的是两个出现奇数次数的数字的异或值eor1

找出该异或值二进制中最右侧的1位，假设两个数分别为A和B，那么该位置上A为0，B为1

将数组内所有数与该位置进行比较，若该位置也为1，那么进行异或，因为该位置上为1的数必然是偶数次数的数与奇数次数的B，因此最后的异或值eor2即为B

将eor1与eor2异或，即可消去B，得到A

```java
public static void printOddTimesNum2(int[] arr) {
        int eor1 = 0;
        for (int i = 0; i < arr.length; i++) {
            eor1 ^= arr[i];
        }
        // a 和 b是两种数
        // eor != 0
        // eor最右侧的1，提取出来
        // eor :     00110010110111000
        //-eor :     11001101001001000 取负等于反码加一
        // rightOne :00000000000001000
        int rightOne = eor1 & (-eor1); // 提取出最右的1

        int eor2 = 0; // eor'
        for (int i = 0; i < arr.length; i++) {
            //  arr[1] =  111100011110000
            // rightOne=  000000000010000
            if ((arr[i] & rightOne) != 0) {
                eor2 ^= arr[i];
            }
        }
        System.out.println("第一个数为："+eor1 + "，第二个数为：" + (eor1 ^ eor2));
    }
```

##### 附加：求一个数二进制中1位置有多少个

```java
// 求一个数位置上有多少个1
    public static int bit1counts(int N) {
        int count = 0;

        //   N:011011010000
        //  -N:100100110000
        //   R:000000010000
        // N^R:011011000000
        while (N != 0) {
            int rightOne = N & ((~N) + 1);
            count++;
            N ^= rightOne;
            // N -= rightOne
        }
        return count;
    }
```



#### CODE03_一个组中有一种数出现K次，其他数都出现了M次

##### 数组中所有的数都出现了M次，只有一种数出现了K次

已知1 <= K < M，找到出现了K次的数
要求额外空间复杂度O(1)，时间复杂度O(N)

```java
// 只有一种数出现了K次，其他数都出现了M次
	public static int onlyKTimes(int[] arr, int k, int m) {
		if (map.size() == 0) {
			mapCreater(map); // 一个map，记录了二进制中数值与位置的映射，如 32 -> 5，64 -> 6
		}
		int[] t = new int[32];
		
		// 数组t中记录了每个位置的1出现了几次
		// t[0] 0位置的1出现了几个
		// t[i] i位置的1出现了几个
		for (int num : arr) {
			while (num != 0) {
				int rightOne = num & (-num);
				t[map.get(rightOne)]++;
				num ^= rightOne; // 最右侧的1与该数字本身异或，消去该位置的1，循环计算出下一个最右侧的1
			}
		}
		int ans = 0;

		// 数组t中遍历，若该位置的1出现次数无法被m除尽，说明出现k次的数在该位置上也为1，对ans中该位置调整为1
		for (int i = 0; i < 32; i++) {
			if (t[i] % m != 0) {
				ans |= (1 << i);
			}
		}
		// 如果这个出现了K次的数，就是0
		// 那么上面代码中的 : ans |= (1 << i);
		// 就不会发生
		// 那么ans就会一直维持0，最后返回0，也是对的！
		
		return ans;
	}
```

更简洁的写法：

```java
// 更简洁的写法，去掉了辅助映射的数组map
	public static int km(int[] arr, int k, int m) {
		// help数组记录每个位置出现1的次数
		int[] help = new int[32];
				
		// 遍历数组
		for (int num : arr) {
			// 对32个位置进行遍历
			for (int i = 0; i < 32; i++) {
				// 当前值右移 i 后与1与运算，若等于1，说明当前值在 i 位置为1，那么在help数组中对该位置 i 加一
				help[i] += (num >> i) & 1;
			}
		}
		int ans = 0;
		for (int i = 0; i < 32; i++) {
			help[i] %= m;
			if (help[i] != 0) {
				ans |= 1 << i;
			}
		}
		return ans;
	}
```

对数器测试

创建数组：

```java
// 创建数组
	public static int[] randomArray(int maxKinds, int range, int k, int m) {
		// 出现次数为k的数的值
		int ktimeNum = randomNumber(range);

		// Math.random()返回的是≥0但是＜1的数，因此有可能是0，所以要+2，保证数字的种类至少是2个
		int numKinds = (int) (Math.random() * maxKinds) + 2;

		// 数组大小为k * 1 + (numKinds - 1) * m
		int[] arr = new int[k + (numKinds - 1) * m];

		// 先在数组中填入k个ktimeNum
		int index = 0;
		for (; index < k; index++) {
			arr[index] = ktimeNum;
		}

		// 数字种类减去一，并记录已有的数字
		numKinds--;
		HashSet<Integer> set = new HashSet<>();
		set.add(ktimeNum);

		while (numKinds != 0) {
			int curNum = 0;
			// 如果新的随机数已经出现过了，那么重新随机
			do {
				curNum = randomNumber(range);
			} while (set.contains(curNum));

			// 随机完成后，记录，种类减一，并往数组中加入m个该数
			set.add(curNum);
			numKinds--;
			for (int i = 0; i < m; i++) {
				arr[index++] = curNum;
			}
		}
		// arr 填好了，但此时数组是有序的，相同的数字扎堆
		for (int i = 0; i < arr.length; i++) {
			// i 位置的数，随机和j位置的数做交换
			int j = (int) (Math.random() * arr.length);// 0 ~ N-1
			int tmp = arr[i];
			arr[i] = arr[j];
			arr[j] = tmp;
		}
		return arr;
	}
```

获得[-range, +range]之间的一个随机整数

```java
// 获得[-range, +range]之间的一个随机整数
	public static int randomNumber(int range) {
		return (int) (Math.random() * (range + 1)) - (int) (Math.random() * (range + 1));
	}
```

测试：

```java
public static void main(String[] args) {
		int kinds = 5;
		int range = 30;
		int testTime = 100000;
		int max = 9;
		System.out.println("测试开始");
		for (int i = 0; i < testTime; i++) {
			int a = (int) (Math.random() * max) + 1; // a 1 ~ 9
			int b = (int) (Math.random() * max) + 1; // b 1 ~ 9
			int k = Math.min(a, b);
			int m = Math.max(a, b);
			// k < m
			if (k == m) {
				m++;
			}
			int[] arr = randomArray(kinds, range, k, m);
			int ans1 = test(arr, k, m);
			int ans2 = onlyKTimes(arr, k, m);
			int ans3 = km(arr, k, m);
			if (ans1 != ans2 || ans1 != ans3) {
				System.out.println(ans1);
				System.out.println(ans3);
				System.out.println("出错了！");
			}
		}
		System.out.println("测试结束");
	}
```



# 三、单双链表、栈和队列、递归和Master公式、哈希表和有序表的使用和性能

内容：

单链表、双链表

栈、队列

递归的物理实质

评估递归复杂度的Master公式

哈希表的使用和性能

有序表的使用和性能

题目：

## 3.1 单链表、双链表

### 性质

构造单链表

```java
// 单链表
	public static class Node {
		public int value;
		public Node next;

		public Node(int data) {
			value = data;
		}
	}
```

构造双链表

```java
// 双链表
	public static class DoubleNode {
		public int value;
		public DoubleNode last;
		public DoubleNode next;

		public DoubleNode(int data) {
			value = data;
		}
	}
```



### CODE01_反转单链表、反转双链表

反转单链表

```java
// 单链表逆转
	public static Node reverseLinkedList(Node head) {
		Node pre = null;
		Node next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			pre = head;
			head = next;
		}
		return pre;
	}
```

反转双链表

```java
public static DoubleNode reverseDoubleList(DoubleNode head) {
		DoubleNode pre = null;
		DoubleNode next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			head.last = next;
			pre = head;
			head = next;
		}
		return pre;
	}
```

### CODE02_在链表中删除指定值的所有节点

```java
public static Node removeValue(Node head, int num) {
		// 如果head！=null并且head是要删除的值，那么head往下移动一个
		while (head != null) {
			if (head.value != num) {
				break;
			}
			head = head.next;
		}
		// 1 ) head == null
		// 2 ) head != null
		Node pre = head;
		Node cur = head;
		while (cur != null) {
			if (cur.value == num) {
				pre.next = cur.next;
			} else {
				pre = cur;
			}
			cur = cur.next;
		}
		return head;
	}
```

## 3.2 栈和队列

### 性质

栈先进后出，队列先进先出

### CODE03_用双链表实现栈和队列

由于代码中需要泛型的使用，因此先复习一下泛型的使用

#### 泛型

##### 1.**泛型类**

泛型类是指在定义类时使用类型参数。类型参数可以在类的实例化时指定具体的类型。

定义时：

```java
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}
```

使用时：

```java
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String item = stringBox.getItem();

Box<Integer> integerBox = new Box<>();
integerBox.setItem(123);
int number = integerBox.getItem();
```

#### 泛型定义双链表

```java
public static class Node<T> {
		public T value;
		public Node<T> last;
		public Node<T> next;

		public Node(T data) {
			value = data;
		}
	}
```

#### 用双链表实现队列

可以先定义一个顶部和底部都能出入的类

```java
public static class DoubleEndsQueue<T> {
		public Node<T> head;
		public Node<T> tail;

		public void addFromHead(T value) {
			Node<T> cur = new Node<T>(value);
			if (head == null) {
				head = cur;
				tail = cur;
			} else {
				cur.next = head;
				head.last = cur;
				head = cur;
			}
		}

		public void addFromBottom(T value) {
			Node<T> cur = new Node<T>(value);
			if (head == null) {
				head = cur;
				tail = cur;
			} else {
				cur.last = tail;
				tail.next = cur;
				tail = cur;
			}
		}

		public T popFromHead() {
			if (head == null) {
				return null;
			}
			Node<T> cur = head;
			if (head == tail) {
				head = null;
				tail = null;
			} else {
				head = head.next;
				cur.next = null;
				head.last = null;
			}
			return cur.value;
		}

		public T popFromBottom() {
			if (head == null) {
				return null;
			}
			Node<T> cur = tail;
			if (head == tail) {
				head = null;
				tail = null;
			} else {
				tail = tail.last;
				tail.next = null;
				cur.last = null;
			}
			return cur.value;
		}

		public boolean isEmpty() {
			return head == null;
		}

	}
```

队列只能顶部入底部出

```java
public static class MyQueue<T> {
		private DoubleEndsQueue<T> queue;

		public MyQueue() {
			queue = new DoubleEndsQueue<T>();
		}

		public void push(T value) {
			queue.addFromHead(value);
		}

		public T poll() {
			return queue.popFromBottom();
		}

		public boolean isEmpty() {
			return queue.isEmpty();
		}

	}
```

#### 用双链表实现栈

栈只能顶部入顶部出

```java
public static class MyStack<T> {
		private DoubleEndsQueue<T> queue;

		public MyStack() {
			queue = new DoubleEndsQueue<T>();
		}

		public void push(T value) {
			queue.addFromHead(value);
		}

		public T pop() {
			return queue.popFromHead();
		}

		public boolean isEmpty() {
			return queue.isEmpty();
		}

	}
```

### COD04_用环形数组实现队列

```java
public static class MyQueue {
		private int[] arr;
		private int end;// end
		private int begin;// begin
		private int size;
		private final int limit;

		public MyQueue(int limit) {
			arr = new int[limit];
			end = 0;
			begin = 0;
			size = 0;
			this.limit = limit;
		}

		public void push(int value) {
			if (size == limit) {
				throw new RuntimeException("队列满了，不能再加了");
			}
			size++;
			arr[end] = value;
			end = nextIndex(end);
		}

		public int pop() {
			if (size == 0) {
				throw new RuntimeException("队列空了，不能再拿了");
			}
			size--;
			int ans = arr[begin];
			begin = nextIndex(begin);
			return ans;
		}

		public boolean isEmpty() {
			return size == 0;
		}

		// 如果现在的下标是i，返回下一个位置
		private int nextIndex(int i) {
			return i < limit - 1 ? i + 1 : 0;
		}

	}
```

### CODE05_实现有getMin功能的栈

```java
public static class MyStack1 {
		// 一个栈用于存数据
		private Stack<Integer> stackData;
		// 一个栈用于存最小值
		private Stack<Integer> stackMin;

		public MyStack1() {
			this.stackData = new Stack<Integer>();
			this.stackMin = new Stack<Integer>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum <= this.getmin()) {
				this.stackMin.push(newNum);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (this.stackData.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			int value = this.stackData.pop();
			if (value == this.getmin()) {
				this.stackMin.pop();
			}
			return value;
		}

		public int getmin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("Your stack is empty.");
			}
			return this.stackMin.peek();
		}
	}
```

### CODE06_两个栈实现队列

其中一个栈记录所有数据，另外一个栈反向记录

入栈时，只有pop栈是空的时，push栈将其所有的数都入pop栈

push:			pop:	1

pop栈非空时，就只入push即可

push:	2 3 4 5		pop:	1

要取出数时，按照队列的规则，先进先出，应该取到1

直接从pop栈中取即可，如果pop栈是空的，那么从push中倒入pop栈中再取

push:	2 3 4 5		pop:	1(取走)

再取

push:						pop:	5 4 3 2(取走)

```java
public static class TwoStacksQueue {
		// 一个栈用来push
		public Stack<Integer> stackPush;
		// 一个栈用来pop
		public Stack<Integer> stackPop;

		public TwoStacksQueue() {
			stackPush = new Stack<Integer>();
			stackPop = new Stack<Integer>();
		}

		// push栈向pop栈倒入数据
		private void pushToPop() {
			if (stackPop.empty()) {
				while (!stackPush.empty()) {
					stackPop.push(stackPush.pop());
				}
			}
		}

		public void add(int pushInt) {
			stackPush.push(pushInt);
			pushToPop();
		}

		public int poll() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			}
			pushToPop();
			return stackPop.pop();
		}

		public int peek() {
			if (stackPop.empty() && stackPush.empty()) {
				throw new RuntimeException("Queue is empty!");
			}
			pushToPop();
			return stackPop.peek();
		}
	}
```

### CODE07_两个队列实现栈

两个队列来回倒

Q:	5 4 3 2 1

这是如果要按照栈的规则取出，那么应该取出5

将Q中的所有数依次取出放到H中，剩余最后一个则是栈要取出的数

Q:	5			H:	4 3 2 1

然后将Q和H指针互换

Q:	4 3 2 1

```java
public static class TwoQueueStack<T> {
		// 一个队列
		public Queue<T> queue;
		public Queue<T> help;

		public TwoQueueStack() {
			queue = new LinkedList<>();
			help = new LinkedList<>();
		}

		public void push(T value) {
			queue.offer(value);
		}

		public T poll() {
			while (queue.size() > 1) {
				help.offer(queue.poll());
			}
			T ans = queue.poll();
			Queue<T> tmp = queue;
			queue = help;
			help = tmp;
			return ans;
		}

		public T peek() {
			while (queue.size() > 1) {
				help.offer(queue.poll());
			}
			T ans = queue.poll();
			help.offer(ans);
			Queue<T> tmp = queue;
			queue = help;
			help = tmp;
			return ans;
		}

		public boolean isEmpty() {
			return queue.isEmpty();
		}

	}
```

## 3.3 递归

### CODE08_用递归行为得到数组中的最大值，并用master公式来估计时间复杂度

#### 简单的递归得到数组中最大值

逻辑图可以用树形图来画

```java
// 求arr中的最大值
	public static int getMax(int[] arr) {
		return process(arr, 0, arr.length - 1);
	}

	// arr[L..R]范围上求最大值  L ... R   N
	public static int process(int[] arr, int L, int R) {
		// arr[L..R]范围上只有一个数，直接返回。即base case ，递归返回的条件
		if (L == R) { 
			return arr[L];
		}
		// L...R 不只一个数
		// mid = (L + R) / 2
		// 防止L和R很大导致相加溢出
		int mid = L + ((R - L) >> 1);
		int leftMax = process(arr, L, mid);
		int rightMax = process(arr, mid + 1, R);
		return Math.max(leftMax, rightMax);
	}
```

####   MASTER公式

![image-20250225171423683](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20250225171423683.png)

由此可以计算出，刚才递归计算数组最大值的方法，T(N) = 2 * T(N/2) + O(1)

a = 2 , b = 2 , d = 0

为第二种情况，时间复杂度为O(N)

## 3.4 哈希表和有序表

### CODE09_哈希表和有序表的性质

##### 哈希表

1. 哈希表中，不管哈希表有多大，增删改查的复杂度都是O(1)

2. 哈希表中，如果是基础类型，那么基础类型有多大，占用空间就有多大，例如String，那么是64字节；如果不是基础类型，那么仅是存内存地址，8字节 

3. 哈希表中基础类型都按值传递，而不是按引用传递

   ```java
   HashMap<Integer,String> test= new HashMap<>();
   Integer a=19000000;
   Integer b=19000000;
   System.out.println(a==b);// false
   test.put(a,"我是3”);
   System.out.println(test.containsKey(b));// true
   ```

4. 哈希表中非基础类型是引用传递

   

##### 有序表

1. 有序表，例如红黑树，avl，sb树，跳表等

2. 有序表中，按照key大小排列，可以查询最小的key，最大的key，可以用floorKey(x)查询≤x最大的key，可以用ceilingKey(x)查询≥x最小的key

3. 有序表中增删改查的复杂度是O(logN)

4. 非基础类型想要存入有序表的话，需要定义比较器compare

   

# 四、 归并排序及其常见面试题

## 归并排序

时间复杂度是 **O(n log n)**

1. **分解（Divide）**：
   - 将待排序的数组从中间分成两个子数组。
   - 递归地对这两个子数组进行归并排序，直到子数组的长度为1（此时子数组已经有序）。
2. **合并（Merge）**：
   - 将两个有序的子数组合并成一个有序的数组。
   - 合并时，从两个子数组的开头依次比较元素，将较小的元素放入结果数组中，直到其中一个子数组的所有元素都被放入结果数组。
   - 将另一个子数组剩余的元素直接放入结果数组。

假设有一个数组 `[38, 27, 43, 3, 9, 82, 10]`，归并排序的过程如下：

1. 分解为 `[38, 27, 43, 3]` 和 `[9, 82, 10]`。
2. 递归分解，直到子数组长度为1。
3. 合并子数组，得到最终的有序数组 `[3, 9, 10, 27, 38, 43, 82]`。

## CODE01_归并排序的递归和非递归实现

递归

```java
// 递归方法实现
	public static void mergeSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process(arr, 0, arr.length - 1);
	}


// T(N) = 2 * T(N / 2) + O(N)
// O(N * logN)
public static void process(int[] arr, int L, int R) {
		if (L == R) { // base case
			return;
		}
		int mid = L + ((R - L) >> 1);
		process(arr, L, mid);
		process(arr, mid + 1, R);
		merge(arr, L, mid, R);
	}

	public static void merge(int[] arr, int L, int M, int R) {
		int[] help = new int[R - L + 1];
		int i = 0;
		int p1 = L;
		int p2 = M + 1;
		while (p1 <= M && p2 <= R) {
			help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
		}
		// 要么p1越界了，要么p2越界了
		while (p1 <= M) {
			help[i++] = arr[p1++];
		}
		while (p2 <= R) {
			help[i++] = arr[p2++];
		}
		for (i = 0; i < help.length; i++) {
			arr[L + i] = help[i];
		}
	}
```

非递归

```java
// 非递归方法实现
	public static void mergeSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		// 步长
		int mergeSize = 1;
		while (mergeSize < N) { // log N
			// 当前左组的，第一个位置
			int L = 0;
			while (L < N) {
				if (mergeSize >= N - L) {
					break;
				}
				int M = L + mergeSize - 1;
				int R = M + Math.min(mergeSize, N - M - 1);
				merge(arr, L, M, R);
				L = R + 1;
			}
			// 防止溢出
			if (mergeSize > N / 2) {
				break;
			}
			mergeSize <<= 1;
		}
	}
```

## CODE02_小和问题

在一个数组中，一个数左边比它小的数的总和，叫该数的小和

所有数的小和累加起来，叫数组小和
例子： [1,3,4,2,5] 
1左边比1小的数：没有
3左边比3小的数：1
4左边比4小的数：1、3
2左边比2小的数：1
5左边比5小的数：1、3、4、 2
所以数组的小和为1+1+3+1+1+3+4+2=16 
给定一个数组arr，求数组小和，要求O(NlogN)

解题思路：

原本思路是，指针指向i，计算i左侧每个比i小的数a、b、c，累加abc为i的小和，然后指针往右移，累加所有数的小和

更改思路为，指针指向i，计算i右侧有多少个比i大的数，如果有x个比i大的数，那么累加x*i，指针向右移动，但这样做前提是序列是有序的

归并排序可以做到左与右每个部分内部都是有序的，它最开始将所有数单独分为一组，每个左组右组内部只有一个数，因此内部是有序的。而后续每次再对比左右组时，也都是有序的。

对比左右组时，左组指针L指向左组第一个数，右组指针R指向右组第一个数。若L>R，说明R是左右组最小的数，但现在要找右侧比左侧大的数，因此R指向的数先放入数组，R右移，再次比较L和R，若此时L＜R，那么此时产生了右侧数比左侧大，计算R及其右侧还有多少个数，就有多少个比L大的数，记录，L指向的数完成计算，放入数组，L右移。

若对比的时候出现L等于R的情况，无法判断R右侧有多少个比L大的数，因此不记录，把R的数放入数组，R右移，直到R>L。

```java
public static int smallSum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    private static int process(int[] arr, int L, int R) {
        // base case
        if (L == R) {
            return 0;
        }
        int M = L + ((R - L) >> 1);
        return process(arr, L, M) + process(arr, M + 1, R) + merge(arr, L, M, R);
    }

    private static int merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        int res = 0;
        int i = 0;
        int p1 = l;
        int p2 = m + 1;
        while (p1 <= m && p2 <= r) {
            res += arr[p1] < arr[p2] ? arr[p1] * (r - p2 + 1) : 0;
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[l++] = help[i];
        }
        return res;
    }
```



## CODE03_给定一个数组arr，求数组的降序对总数量

数组中，一个数后面有多少个数小于它，那么和它成为一个降序对，求一个数组中有多少个降序对

依然是归并思想，不同的是指针的选择，分好左右组后，p1指针先指向m，p2指针先指向r，也就是左右两组的最右侧，由于左右两组都是组内增序的，如果p1大于p2，那么说明p2及其左侧直到m+1位置的数都比p1小，都是p1的降序对，记录好后p1左移；如果p1<=p2，p1已经是左侧最大的数了，将p2左移，如果p1还是<=p2，那么p2继续左移变小，直到p1比p2大。

记录完毕后，再重新指针一次，p1指向l，p2指向m+1，走一遍普通归并的过程，把左右两组合并即可。

```java
public static int reversePair(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    private static int process(int[] arr, int L, int R) {
        // base case
        if (L == R) {
            return 0;
        }
        int M = L + ((R - L) >> 1);
        return process(arr, L, M) + process(arr, M + 1, R) + merge(arr, L, M, R);
    }

    private static int merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        int i = 0;
        int p1 = m;
        int p2 = r;
        int res = 0;
        while(p1>=l&&p2>m){
            if(arr[p1] > arr[p2]){
                res += (p2-m);
                p1--;
            }else{
                p2--;
            }
        }
        p1 = l;
        p2 = m+1;
        while(p1<=m&&p2<=r){
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while(p1<=m){
            help[i++] = arr[p1++];
        }
        while(p2<=r){
            help[i++] = arr[p2++];
        }
        for(i = 0;i<help.length;i++){
            arr[l++] = help[i];
        }
        return res;
    }
```



## CODE04_求一个数组中，一个数比后面的数两倍都大的总对数

在一个数组中，对于任何一个数num，求有多少个大于(后面的数*2)
比如：[3,1,7,0,2]
3的后面有：1，0
1的后面有：0
7的后面有：0，2
0的后面没有
2的后面没有
所以总共有5个

依然是归并思想，p1指向l，p2指向m+1，如果满足p1>两倍的p2，那么p2右移，直到找到一个不满足的p2。如果不满足，那么说明p2以及其后面的所有数都不满足该条件了，只有p2前面的数满足，因此对res加上p2-m-1，并把p1右移。

即使开局就不满足，对res加上p2-m-1，由于p2=m+1，所以也是加0，不影响

```java
public static int biggerThanRightTwice(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    private static int process(int[] arr, int L, int R) {
        // base case
        if (L == R) {
            return 0;
        }
        int M = L + ((R - L) >> 1);
        return process(arr, L, M) + process(arr, M + 1, R) + merge(arr, L, M, R);
    }

    private static int merge(int[] arr, int l, int m, int r) {
        int[] help = new int[r - l + 1];
        int i = 0;

        int p1 = l;
        int p2 = m + 1;
        int res = 0;
//        for(;p1<=m;p1++) {
//            while (p2<=r && arr[p1] > arr[p2] * 2) {
//                p2++;
//            }
//            res += p2 - m - 1;
//        }
        while(p1<=m){
            while(p2<=r && arr[p1] > arr[p2] * 2){
                p2++;
            }
            res += p2 - m - 1;
            p1++;
        }
        p1 = l;
        p2 = m + 1;
        while (p1 <= m && p2 <= r) {
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[l++] = help[i];
        }
        return res;
    }
```



# 五、 归并排序面试题(续)、快速排序

## CODE01_给定一个数组arr，两个整数lower和upper，返回arr中有多少个子数组的累加和在[lower,upper]范围上

### 前缀和

给一个无序数组，要求数组中从i位置到j位置的数的累加，并且这个需求有无限次，怎么样最快？

求出其前缀和数组presum[]，前缀和数组与原数组等长，presum[i]的含义是原数组中从0到i的数的累加

例如arr [ -3,1,2,4,0,-1,5]

presum[-3,-2,0,4,4,3,8]

有了前缀和后，后续要i到j的累加和，直接取presum[j]-presum[i-1]即可。

### 题解

换个思想，如果要求以i位置结尾的子数组的和在[lower,upper]之间，先求出0-i的整体和为x，那么该问题等同于在0-i中有多少个前缀和在[x-upper,x-lower]上，如果0-j的前缀和是y，那么(j+1)-i的和则为x-y，想要x-y落在[lower,upper]之间，则必须y落在[x-upper,x-lower]上  

```java
public static int countOfRangeSum(int[] arr, int lower, int upper) {
        if (arr == null || arr.length < 1) {
            return 0;
        }
        long[] presum = new long[arr.length];
        presum[0] = arr[0];
        for (int i = 1; i < arr.length; i++) {
            presum[i] = presum[i - 1] + arr[i];
        }
        return process(presum, 0, arr.length - 1, lower, upper);
    }

    private static int process(long[] presum, int l, int r, int lower, int upper) {
        // base case
        // 如果左等于右，说明组内只有一个数，这个数是前缀和，代表了0-l的数的和，如果在范围内，那么对结果加一
        if (l == r) {
            if (presum[l] >= lower && presum[l] <= upper) {
                return 1;
            }
        } else {
            return 0;
        }

        int m = l + ((r - l) >> 1);
        return process(presum, l, m, lower, upper)
                + process(presum, m + 1, r, lower, upper)
                + merge(presum, l, m, r, lower, upper);
    }

    private static int merge(long[] presum, int l, int m, int r, int lower, int upper) {
        long[] help = new long[presum.length];
        int res = 0;
        // LR为窗口左右边界，目的是从左组第一个开始向右滑动
        int L = l;
        int R = l;
        // p指向右组第一个，目的是从右组第一个开始比较左组有多少个符合它的区间
        for (int p = m + 1; p <= r; p++) {
            // 由于右组已经被排序过了，因此presum[p]不一定是0-p的数的和
            // 但是可以确定的是，presum[p]一定是0-x的数的和，x＞所有左组的下标
            // 左组中的每个值都代表0-y的值
            // 假设presum[p]的值是X，左组中有个值是Y，是0-y-1的数的和，那么只要X-Y落在[lower,upper]，就说明y-x的数的和是符合的
            // 也就是Y要落在[X-lower,X-upper]上
            long max = presum[p] - lower;
            long min = presum[p] - upper;
            while (presum[R] >= max) {
                R++;
            }
            while (presum[L] < min) {
                L++;
            }
            res += R - L;
        }

        int p1 = l;
        int p2 = m + 1;
        int i = 0;
        while (p1 <= m && p2 <= r) {
            help[i++] = presum[p1] < presum[p2] ? presum[p1++] : presum[p2++];
        }
        while (p1 <= m) {
            help[i++] = presum[p1++];
        }
        while (p2 <= r) {
            help[i++] = presum[p2++];
        }
        for (i = 0; i < help.length; i++) {
            presum[l++] = help[i];
        }
        return res;

    }
```

## CODE02_荷兰国旗问题

一个无序数组，以最右侧的数为划分值，使数组中分成左中右三组，左组都比划分值小，中组等于划分值，右组都比划分值大

时间复杂度要在O（N）   

最开始左组指向L-1位置，右组指向R位置，因为R位置的是划分值，不用急着去划分他的位置

指针指向第一个位置L开始，只会发生三种情况

情况一，指针位置的数小于划分值，那么说明指针指向的数属于左组，指针指向的数和左组位置下一个数交换，左组和指针右移一个

情况二，指针位置的数等于划分值，那么说明指针指向的数属于中组，那么指针右移，左组位置不变

情况三，指针位置的数大于划分值，那么说明指针指向的数属于右组，指针指向的数和右组左侧一个的数交换，右组左移，指针不变

直到指针与右组位置碰上，说明全部筛选完毕

```java
public static int[] netherLandsFlag(int[] nums, int L, int R){
        if(L>R){
            return new int[]{-1,-1};
        }
        if(L == R){
            return new int[]{L,R};
        }
        int less = L-1;
        int more = R;
        int index = L;
        while(index < more){
            if(nums[index] < nums[R]){
                swap(nums,index++,++less);
            }else if(nums[index] > nums[R]){
                swap(nums,index,--more);
            }else{
                index++;
            }
        }
        swap(nums,index,R);
        return new int[]{less+1,more};
    }
```

## CODE03_快速排序从1.0到3.0的实现

快排的时间复杂度是O(NlogN)，空间复杂度是O(logN)

递归版本

1.0

```java
	// arr[L..R]上，以arr[R]位置的数做划分值
	// <= X > X
	// <= X X
	// 返回arr[R]应该在的位置，左侧都小于等于它，右侧都大于它
	public static int partition(int[] arr, int L, int R) {
		if (L > R) {
			return -1;
		}
		if (L == R) {
			return L;
		}
		int lessEqual = L - 1;
		int index = L;
		while (index < R) {
			if (arr[index] <= arr[R]) {
				swap(arr, index, ++lessEqual);
			}
			index++;
		}
		swap(arr, ++lessEqual, R);
		return lessEqual;
	}
	
	// 快排1.0
	// 每次最右侧数摆在该摆的位置，左右两侧是比他小/大的数
	public static void quickSort1(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process1(arr, 0, arr.length - 1);
	}

	public static void process1(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		// L..R partition arr[R] [ <=arr[R] arr[R] >arr[R] ]
		int M = partition(arr, L, R);
		process1(arr, L, M - 1);
		process1(arr, M + 1, R);
	}
```

2.0

```java
// 快排2.0
	// 每次选最右侧数，相同的摆在一起，左右是比他小/大的数
	public static void quickSort2(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process2(arr, 0, arr.length - 1);
	}

	// arr[L...R] 排有序，快排2.0方式
	public static void process2(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		// [ equalArea[0]  ,  equalArea[0]]
		int[] equalArea = netherlandsFlag(arr, L, R);
		process2(arr, L, equalArea[0] - 1);
		process2(arr, equalArea[1] + 1, R);
	}
```

3.0

```java
// 快排递归版本3.0
	// 比2.0多了个每轮随机选一个数来比较
	public static void quickSort3(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		process3(arr, 0, arr.length - 1);
	}


	public static void process3(int[] arr, int L, int R) {
		if (L >= R) {
			return;
		}
		swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
		int[] equalArea = netherlandsFlag(arr, L, R);
		process3(arr, L, equalArea[0] - 1);
		process3(arr, equalArea[1] + 1, R);
	}
```

非递归实现

用栈替代递归调用，手动记录每次要处理的范围

```java
	// 快排非递归版本需要的辅助类
	// 用来记录要处理的是什么范围上的排序
	public static class Op {
		public int l;
		public int r;

		public Op(int left, int right) {
			l = left;
			r = right;
		}
	}

	// 快排3.0 非递归版本 用栈来执行
	public static void quickSort4(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		swap(arr, (int) (Math.random() * N), N - 1);
		int[] equalArea = netherlandsFlag(arr, 0, N - 1);
		int el = equalArea[0];
		int er = equalArea[1];
		Stack<Op> stack = new Stack<>();
		stack.push(new Op(0, el - 1));
		stack.push(new Op(er + 1, N - 1));
		while (!stack.isEmpty()) {
			Op op = stack.pop(); // op.l ... op.r
			if (op.l < op.r) {
				swap(arr, op.l + (int) (Math.random() * (op.r - op.l + 1)), op.r);
				equalArea = netherlandsFlag(arr, op.l, op.r);
				el = equalArea[0];
				er = equalArea[1];
				stack.push(new Op(op.l, el - 1));
				stack.push(new Op(er + 1, op.r));
			}
		}
	}
```

用队列替代递归调用，手动记录每次要处理的范围，与栈操作其实是一样的，在队列中存入要记录的范围，一个个取出来处理即可

```java
// 快排3.0 非递归版本 用队列来执行
	public static void quickSort5(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int N = arr.length;
		swap(arr, (int) (Math.random() * N), N - 1);
		int[] equalArea = netherlandsFlag(arr, 0, N - 1);
		int el = equalArea[0];
		int er = equalArea[1];
		Queue<Op> queue = new LinkedList<>();
		queue.offer(new Op(0, el - 1));
		queue.offer(new Op(er + 1, N - 1));
		while (!queue.isEmpty()) {
			Op op = queue.poll();
			if (op.l < op.r) {
				swap(arr, op.l + (int) (Math.random() * (op.r - op.l + 1)), op.r);
				equalArea = netherlandsFlag(arr, op.l, op.r);
				el = equalArea[0];
				er = equalArea[1];
				queue.offer(new Op(op.l, el - 1));
				queue.offer(new Op(er + 1, op.r));
			}
		}
	}
```

快速排序的递归实现和非递归实现

## CODE04_双向链表进行快速排序的code实现





# 六、 比较器、堆结构、堆排序

## 6.1比较器

通过自定义比较器，可以实现引用类型的自动排序

### 1.正常方法

以一个学生类为例

```java
public static class Student {
		public String name;
		public int id;
		public int age;

		public Student(String name, int id, int age) {
			this.name = name;
			this.id = id;
			this.age = age;
		}
	}
```

```java
// 任何比较器：
	// compare方法里，遵循一个统一的规范：
	// 返回负数的时候，认为第一个参数应该排在前面。也就是第一个参数小于第二个参数
	// 返回正数的时候，认为第二个参数应该排在前面
	// 返回0的时候，认为无所谓谁放前面
	public static class IdShengAgeJiangOrder implements Comparator<Student> {

		// 根据id从小到大，但是如果id一样，按照年龄从大到小
		@Override
		public int compare(Student o1, Student o2) {
			return o1.id != o2.id ? (o1.id - o2.id) : (o2.age - o1.age);
		}

	}
```

在排序时，除了将要比较的数组放进去以外，还要放入比较器

```java
		Student student1 = new Student("A", 4, 40);
		Student student2 = new Student("B", 4, 21);
		Student student3 = new Student("C", 3, 12);
		Student student4 = new Student("D", 3, 62);
		Student student5 = new Student("E", 3, 42);
		// D E C A B

		Student[] students = new Student[] { student1, student2, student3, student4, student5 };
		System.out.println("第一条打印");

		Arrays.sort(students, new IdShengAgeJiangOrder());
		for (int i = 0; i < students.length; i++) {
			Student s = students[i];
			System.out.println(s.name + "," + s.id + "," + s.age);
		}
```

如果是列表

```java
		ArrayList<Student> studentList = new ArrayList<>();
		studentList.add(student1);
		studentList.add(student2);
		studentList.add(student3);
		studentList.add(student4);
		studentList.add(student5);
		studentList.sort(new IdShengAgeJiangOrder());
```

### 2.简单方法

现用现写规则

```java
		student1 = new Student("A", 4, 40);
		student2 = new Student("B", 4, 21);
		student3 = new Student("C", 4, 12);
		student4 = new Student("D", 4, 62);
		student5 = new Student("E", 4, 42);
		TreeMap<Student, String> treeMap = new TreeMap<>((a, b) -> (a.id - b.id));
```



## 6.2 堆结构

### 1.完全二叉树

在一个数组中，任意i结点，它的左孩子坐标为2*i+1，右孩子坐标为2*i+2，父坐标为 (i-1)/2

### CODE01_建堆

每个堆都是完全二叉树，其中每个节点都不其孩子结点大，称为大根堆，反之称为小根堆

建立根堆

```java
public static class MyMaxHeap {
        private int[] heap;
        private final int limit;
        private int heapsize;

        public MyMaxHeap(int limit) {
            this.limit = limit;
            heap = new int[limit];
            heapsize = 0;
        }

        private boolean isEmpty() {
            return heapsize == 0;
        }

        private boolean isFull() {
            return heapsize == limit;
        }

        private void push(int v) {
            if (this.isFull()) {
                throw new RuntimeException("堆已满");
            }
            heap[heapsize] = v;
            heapInsert(heap, heapsize++);
        }

        private int pop() {
            if (this.isEmpty()) {
                throw new RuntimeException("堆是空的");
            }
            int ans = heap[0];
            swap(heap, 0, --heapsize);
            heapify(heap, 0, heapsize);
            return ans;
        }

        private int peek() {
            if (this.isEmpty()) {
                throw new RuntimeException("堆是空的");
            }
            return heap[0];
        }


        private void swap(int[] arr, int i, int j) {
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }

        private void heapInsert(int[] heap, int index) {
            while (heap[index] > heap[(index - 1) / 2]) {
                swap(heap, index, (index - 1) / 2);
                index = (index - 1) / 2;
            }
        }

        private void heapify(int[] heap, int index, int heapsize) {
            int left = (index * 2) + 1;
            while (left < heapsize) {
                int largest = left + 1 < heapsize ? (heap[left] > heap[left + 1] ? left : left + 1) : left;
                largest = heap[largest] > heap[index] ? largest : index;
                if(largest == index){
                    break;
                }
                swap(heap,index,largest);
                index = largest;
                left = (index * 2) + 1;
            }
        }
```

设定大根堆还是小根堆，比较器中设定为递增就是小根堆

```java
public static class MyHeapComparator implements Comparator<Integer> {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        }

```

### CODE02_堆排序

```java
public static void heapSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // nlogn，新来的数放最后，从下往上排序
        for(int i = 1;i< arr.length;i++){
            heapinsert(arr,i);
        }
        // n，从末尾开始排序
//        for(int i = arr.length-1;i>=0;i--){
//            heapify(arr,arr.length,i);
//        }
        int heapsize = arr.length;
        swap(arr,0,--heapsize);
        while(heapsize>0){
            heapify(arr,heapsize,0);
            swap(arr,0,--heapsize);
        }


    }

    public static void heapify(int[] arr, int heapsize, int index) {
        int left = index * 2 + 1;
        while (left < heapsize) {
            int max = left + 1 < heapsize ? (arr[left] > arr[left +1] ? left : left+1) : left;
            max = arr[max] > arr[index] ? max : index;
            if(max == index){
                break;
            }
            swap(arr,index,max);
            index = max;
            left = index * 2 + 1;
        }
    }

    public static void heapinsert(int[] arr,int index) {
        while (arr[index] > arr[(index-1 )/ 2 ]) {
            swap(arr,index,(index-1 )/ 2 );
            index = (index-1 )/ 2;
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```



### CODE03_已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k

k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。 

解题思路：从0开始，0位置要放最小的数，这个最小的数距离0的距离不会超过k，那么一定在0~k之间。那么从k位置开始想上进行小根堆调整，即可将最小的数放到0位置上，时间复杂度为logk。一共有N个数，时间复杂度最多Nlogk，优于NlogN

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
		if (k == 0) {
			return;
		}
		// PriorityQueue是优先级队列，优先级最高的元素会显出队。默认小根堆，也可以自己改比较器来控制什么是优先级
		PriorityQueue<Integer> heap = new PriorityQueue<>();
		int index = 0;
		// 0...K-1
		for (; index <= Math.min(arr.length - 1, k - 1); index++) {
			heap.add(arr[index]);
		}
		int i = 0;
		for (; index < arr.length; i++, index++) {
			heap.add(arr[index]);
			arr[i] = heap.poll();
		}
		while (!heap.isEmpty()) {
			arr[i++] = heap.poll();
		}
	}
```



# 七、 和堆有关的面试题、加强堆结构

## CODE01_线段最大重合问题

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段



解题思路：将每个线段按照起始位置从小到大排序，从最小起始位置的线段开始入小根堆，放入小根堆的是线段的终点位置。

每次入堆都要对比一下此时入堆的线段的起始位置和当前堆顶的数，如果当前线段的起始位置大于当前堆顶数，那么意为该线段的起始位置在目前堆顶线段的终点位置，两者必然没有重合，将堆顶出堆。反复对比，直到当前线段的起始位置不大于当前堆顶数，也就是现在在堆中的所有线段的终点位置都在当前线段的起始位置的右侧，必然有重合。将当前线段的重点位置入堆，记录现在堆的大小，即为当前有多少个重合的线段，如果比当前最大值大，那么最大值等于该值。

直到所有线段都入过堆，就可以得到最多重合的值。

```java
public static int coverMax1(int[][] lines) {
        Line[] ls = new Line[lines.length];
        for (int i = 0; i < lines.length; i++) {
            Line line = new Line(lines[i][0], lines[i][1]);
            ls[i] = line;
        }
        // 以开始位置从小到大排序
        Arrays.sort(ls, new StartComparator());
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        int max = 0;
        for (int i = 0; i < lines.length; i++) {
            while (!minHeap.isEmpty() && ls[i].start >= minHeap.peek()) {
                minHeap.poll();
            }
            minHeap.add(ls[i].end);
            max = Math.max(max, minHeap.size());
        }
        return max;
    }

    public static int coverMax2(int[][] lines) {
        Arrays.sort(lines, (a, b) -> (a[0] - b[0]));
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        int max = 0;
        for (int i = 0; i < lines.length; i++) {
            while (!minHeap.isEmpty() && lines[i][0] >= minHeap.peek()) {
                minHeap.poll();
            }
            minHeap.add(lines[i][1]);
            max = Math.max(max, minHeap.size());
        }
        return max;
    }

    public static class Line {
        public int start;
        public int end;

        public Line(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static class StartComparator implements Comparator<Line> {
        @Override
        public int compare(Line o1, Line o2) {
            return o1.start - o2.start;
        }
    }
```



## CODE02_加强堆的实现、注意点解析

普通堆通常只有插入、删除、查看顶部、查找（查找的时间复杂度很高）的功能

加强堆在普通堆的基础上增加了快速查找元素、更新堆中某个元素的值、删除任意元素、根据多个优先级排序等功夫

```java
package class07;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

/*
 * T一定要是非基础类型，有基础类型需求包一层
 */
public class HeapGreater<T> {

	private ArrayList<T> heap;
	private HashMap<T, Integer> indexMap;
	private int heapSize;
	private Comparator<? super T> comp; // ? super T 表示一个未知的类型，这个类型是 T 或者 T 的父类

	public HeapGreater(Comparator<? super T> c) {
		heap = new ArrayList<>();
		indexMap = new HashMap<>();
		heapSize = 0;
		comp = c;
	}

	public boolean isEmpty() {
		return heapSize == 0;
	}

	public int size() {
		return heapSize;
	}

	public boolean contains(T obj) {
		return indexMap.containsKey(obj);
	}

	public T peek() {
		return heap.get(0);
	}

	public void push(T obj) {
		heap.add(obj);
		indexMap.put(obj, heapSize);
		heapInsert(heapSize++);
	}

	public T pop() {
		T ans = heap.get(0);
		swap(0, heapSize - 1);
		indexMap.remove(ans);
		heap.remove(--heapSize);
		heapify(0);
		return ans;
	}

	public void remove(T obj) {
		T replace = heap.get(heapSize - 1);
		int index = indexMap.get(obj);
		indexMap.remove(obj);
		heap.remove(--heapSize);
		if (obj != replace) {
			heap.set(index, replace);
			indexMap.put(replace, index);
			resign(replace);
		}
	}

	public void resign(T obj) {
		heapInsert(indexMap.get(obj));
		heapify(indexMap.get(obj));
	}

	// 请返回堆上的所有元素
	public List<T> getAllElements() {
		List<T> ans = new ArrayList<>();
		for (T c : heap) {
			ans.add(c);
		}
		return ans;
	}

	private void heapInsert(int index) {
		while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	private void heapify(int index) {
		int left = index * 2 + 1;
		while (left < heapSize) {
			int best = left + 1 < heapSize && comp.compare(heap.get(left + 1), heap.get(left)) < 0 ? (left + 1) : left;
			best = comp.compare(heap.get(best), heap.get(index)) < 0 ? best : index;
			if (best == index) {
				break;
			}
			swap(best, index);
			index = best;
			left = index * 2 + 1;
		}
	}

	private void swap(int i, int j) {
		T o1 = heap.get(i);
		T o2 = heap.get(j);
		heap.set(i, o2);
		heap.set(j, o1);
		indexMap.put(o2, i);
		indexMap.put(o1, j);
	}

}

```



## CODE03_购买得奖，输出得奖名单

给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op
两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
arr= [3,3,1,2,1,2,5…
op = [T,T,T,T,F,T,F…
依次表示：
3用户购买了一件商品
3用户购买了一件商品
1用户购买了一件商品
2用户购买了一件商品
1用户退货了一件商品
2用户购买了一件商品
5用户退货了一件商品…
一对arr[i]和op[i]就代表一个事件：
用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品
op[i] == F就代表这个用户退货了一件商品
现在你作为电商平台负责人，你想在每一个事件到来的时候，
都给购买次数最多的前K名用户颁奖。
所以每个事件发生后，你都需要一个得奖名单（得奖区）。
得奖系统的规则：
1，如果某个用户购买商品数为0，但是又发生了退货事件，
     则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户
2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3，每次都是最多K个用户得奖，K也为传入的参数
      如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
4，得奖系统分为得奖区和候选区，任何用户只要购买数>0，
      一定在这两个区域中的一个
5，购买数最大的前K名用户进入得奖区，
      在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6，如果购买数不足以进入得奖区的用户，进入候选区
7，如果候选区购买数最多的用户，已经足以进入得奖区，
     该用户就会替换得奖区中购买数最少的用户（大于才能替换），
     如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户
     如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户
8，候选区和得奖区是两套时间，
     因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有
     从得奖区出来进入候选区的用户，得奖区时间删除，
     进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
     从候选区出来进入得奖区的用户，候选区时间删除，
     进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
9，如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，
     离开是指彻底离开，哪个区域也不会找到该用户
     如果下次该用户又发生购买行为，产生>0的购买数，
     会再次根据之前规则回到某个区域中，进入区域的时间重记
请遍历arr数组和op数组，遍历每一步输出一个得奖名单
public List<List<Integer>>  topK (int[] arr, boolean[] op, int k)



# 八、 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性



## CODE01_前缀树

可以在O(m)时间内查找一个长度为m的字符串，其中m是字符串的长度。

可以快速找到所有以某个前缀开头的字符串。

共享相同前缀的字符串会共享树中的节点，节省存储空间。

```java
public static class Node1 {
        public int pass;
        public int end;
        public Node1[] nexts;

        public Node1() {
            pass = 0;
            end = 0;
            nexts = new Node1[26];
        }

    }

    public static class Trie1 {
        private Node1 root;

        public Trie1() {
            root = new Node1();
        }

        public void insert(String word) {
            if (word == null) {
                return;
            }
            char[] chars = word.toCharArray();
            root.pass++;
            Node1 node = root;
            int index = 0;
            for (int i = 0; i < chars.length; i++) {
                index = chars[i] - 'a';
                if (node.nexts[index] == null) {
                    node.nexts[index] = new Node1();
                }
                node.nexts[index].pass++;
                node = node.nexts[index];
            }
            node.end++;
        }

        public int search(String word) {
            if (word == null) {
                return 0;
            }
            char[] chars = word.toCharArray();
            int index = 0;
            Node1 node = root;
            for (int i = 0; i < chars.length; i++) {
                index = chars[i] - 'a';
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.end;
        }

        public void delete(String word) {
            if (search(word)!=0) {
                char[] chars = word.toCharArray();
                int index = 0;
                Node1 node = root;
                node.pass--;
                for (int i = 0; i < chars.length; i++) {
                    index = chars[i] - 'a';
                    if (--node.nexts[index].pass == 0) {
                        node.nexts[index] = null;
                        return;
                    }
                    node = node.nexts[index];
                }
                node.end--;
            }
        }

        public int preSearch(String pre) {
            if (pre == null) {
                return 0;
            }
            char[] chars = pre.toCharArray();
            int index = 0;
            Node1 node = root;
            for (int i = 0; i < chars.length; i++) {
                index = chars[i] - 'a';
                if(node.nexts[index] == null){
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.pass;
        }
    }
```



## CODE02_计数排序、基数排序

### 计数排序

以一个非负数组为例，找出数组中的最大值，建一个大小为最大值+1的辅助数组，遍历原数组，每遍历到一个值i，将辅助数组[i]的值+1，即记录每种数一共有几个.

遍历完后，辅助数组的从头开始倒回原数组中

例子：

原数组：3，5，4，1，2，1，1，6，9，7，3，9

​	下标    0，1，2，3，4，5，6，7，8，9

辅助：	0，3，1，2，1，0，1，1，1，2

原数组：1，1，1，2，3，3，4，6，7，8，9，9

```java
public static void countSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int max = Integer.MIN_VALUE;
        for(int i =0;i<arr.length;i++){
            max = Math.max(max,arr[i]);
        }
        int[] bucket = new int[max+1];
        for(int i = 0;i<arr.length;i++){
            bucket[arr[i]]++;
        }
        for(int i=0,j=0;j<bucket.length;j++){
            while(bucket[j]>0){
                arr[i++]=j;
                bucket[j]--;
            }
        }
    }
```

### 基数排序

范围一般是非负的十进制数

找出最大的数是几位的，从个位开始，建立一个0-9的二维数组，按个位数将所有数依次放入对应数组，再从0开始依次取出。再到十位、百位。。

但是这样空间复杂度比较高

复杂但是空间复杂度低的方法：

建一个0-9的数组，从个位数开始，个位数是0的数就在数组0位置上++，遍历完成后可以获得每个数的个位数的出现频率

0	1	2	3	4	5

2	4	1	2	0	1

0位置是2，就是个位数是0的数有2个。1位置是4就是个位数是1的数有4个。

将该数组累加，计算出小于等于该位数的数有几个。

0	1	2	3	4	5

2	6	7	9	9	10

4位置上是9，意思是个位数小于等于4的数有9个

建一个和原数组一样大的辅助数组，将原数组从右往左遍历，对每个数查看它的个位数大小，在记录数组中找到对应位置的值，以5为例，5位置是10，那么个位数小于等于5的数有10个，将这个数排在第十个位置，也就是放在辅助数组[9]上，将记录数组中5位置的值-1。

```java
public static void radixSort(int[] arr){
        if(arr == null|| arr.length < 2){
            return;
        }
        radixSort(arr,0,arr.length-1,maxbits(arr));
    }

    private static void radixSort(int[] arr, int L, int R, int maxbits) {
        int[] help = new int[R-L+1];

        for(int d =1;d<=maxbits;d++){
            int[] count = new int[10];
            for(int i =L;i<=R;i++){
                int index = (arr[i]/(int)Math.pow(10,d-1))%10;
                count[index]++;
            }
            for(int i =1;i<10;i++){
                count[i] = count[i]+count[i-1];
            }
            for(int j =R;j>=L;j--){
                int index = (arr[j]/(int)Math.pow(10,d-1))%10;
                help[count[index]-1] = arr[j];
                count[index]--;
            }
            for(int i =0,j=L;i<help.length;i++){
                arr[j++] = help[i];
            }
        }
    }

    public static int maxbits(int[] arr){
        int max = Integer.MIN_VALUE;
        for(int i =0;i<arr.length;i++){
            max = Math.max(max,arr[i]);
        }
        int ans = 0;
        while(max!=0){
            ans++;
            max /=10;
        }
        return ans;
    }
```



# 九、 排序算法大总结、链表及其相关面试题

## 排序算法总结

1.不基于比较的排序，对样本数据有严格要求，不易改写

2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用

3.基于比较的排序，时间复杂度的极限是O(N*logN)

4.时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。

5.为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

​			归并				快排				堆排		

时间	NlogN			NlogN			  NlogN	

空间		N				  logN					1

稳定        √					  ×					   ×





工程上对排序的常见改进

## 链表题

### 常见技巧

笔试可以用容器，时间复杂度第一，空间复杂度可以不考虑

面试不要用容器，在保证时间复杂度的同时，空间复杂度尽可能的小
常用：容器（哈希表，数组），快慢指针



### CODE01_快慢指针四题

输入链表头节点，奇数长度返回中点，偶数长度返回上中点
输入链表头节点，奇数长度返回中点，偶数长度返回下中点
输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

解题思路：

用快慢指针，快慢指针同时指向头节点，快指针每次走两步，慢指针每次走一步，判断边界。

```java
package class09;

import java.util.ArrayList;

public class Test_LinkedListMid {
    public static class Node {
        public int value;
        public Node next;

        public Node(int v) {
            value = v;
        }
    }

    public static Node returnMidOrUp(Node head) {
        // 节点有三个及以上
        if (head == null || head.next == null||head.next.next == null) {
            return head;
        }
        Node fast = head.next.next;
        Node slow = head.next;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public static Node returnMidOrDown(Node head) {
        // 节点有2个及以上
        if (head == null || head.next == null) {
            return head;
        }
        Node fast = head.next;
        Node slow = head.next;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public static Node returnUpOrUp(Node head) {
        // 节点有三个及以上
        if (head == null || head.next == null||head.next.next == null) {
            return head;
        }
        Node fast = head.next.next;
        Node slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public static Node returnDownOrDown(Node head){
        // 节点有三个及以上
        if (head == null || head.next == null||head.next.next == null||head.next.next.next==null) {
            return head;
        }
        Node fast = head.next.next;
        Node slow = head.next;
        while (fast.next != null && fast.next.next != null&&fast.next.next.next!=null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }

    public static Node right1(Node head) {
        if (head == null) {
            return null;
        }
        Node cur = head;
        ArrayList<Node> arr = new ArrayList<>();
        while (cur != null) {
            arr.add(cur);
            cur = cur.next;
        }
        return arr.get((arr.size() - 1) / 2);
    }

    public static Node right2(Node head) {
        if (head == null) {
            return null;
        }
        Node cur = head;
        ArrayList<Node> arr = new ArrayList<>();
        while (cur != null) {
            arr.add(cur);
            cur = cur.next;
        }
        return arr.get(arr.size() / 2);
    }

    public static Node right3(Node head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node cur = head;
        ArrayList<Node> arr = new ArrayList<>();
        while (cur != null) {
            arr.add(cur);
            cur = cur.next;
        }
        return arr.get((arr.size() - 3) / 2);
    }

    public static Node right4(Node head) {
        if (head == null || head.next == null) {
            return null;
        }
        Node cur = head;
        ArrayList<Node> arr = new ArrayList<>();
        while (cur != null) {
            arr.add(cur);
            cur = cur.next;
        }
        return arr.get((arr.size() - 2) / 2);
    }

    public static void main(String[] args) {
        Node test = null;
        test = new Node(0);
        test.next = new Node(1);
        test.next.next = new Node(2);
        test.next.next.next = new Node(3);
        test.next.next.next.next = new Node(4);
        test.next.next.next.next.next = new Node(5);
        test.next.next.next.next.next.next = new Node(6);
        test.next.next.next.next.next.next.next = new Node(7);
        test.next.next.next.next.next.next.next.next = new Node(8);
        test.next.next.next.next.next.next.next.next.next = new Node(9);
        test.next.next.next.next.next.next.next.next.next.next = new Node(10);

        Node ans1 = null;
        Node ans2 = null;

        ans1 = returnMidOrUp(test);
        ans2 = right1(test);
        System.out.println(ans1 != null ? ans1.value : "无");
        System.out.println(ans2 != null ? ans2.value : "无");

        ans1 = returnMidOrDown(test);
        ans2 = right2(test);
        System.out.println(ans1 != null ? ans1.value : "无");
        System.out.println(ans2 != null ? ans2.value : "无");

        ans1 = returnUpOrUp(test);
        ans2 = right3(test);
        System.out.println(ans1 != null ? ans1.value : "无");
        System.out.println(ans2 != null ? ans2.value : "无");

        ans1 = returnDownOrDown(test);
        ans2 = right4(test);
        System.out.println(ans1 != null ? ans1.value : "无");
        System.out.println(ans2 != null ? ans2.value : "无");

    }

}

```

### CODE02_给定一个单链表的头节点head，请判断该链表是否为回文结构

解题思路：

回文类题目，如果可以用容器的话，直接放入栈中再弹出即可。也可以先找到中点，中点往右的部分放入栈，可以省一半的空间。

不用容器的话，利用快慢指针找到中点，中点右侧的结点next指针反方向指，中点指向null，保留右侧末尾的指针L

L和R从两边往中间移动，对比，直到L和R其中一个等于NULL

例：	1	->	2	->	3	->	3	->	2	->	1

变成    1	->	2	->	3	<-	3	<-	2	<-	1

​			L						 |								       R

​									  null

```java
package class09;

public class Test_IsPalindromeList {

    public static class Node {
        public int value;
        public Node next;

        public Node(int v) {
            value = v;
        }
    }

    public static boolean isPalindrome(Node head) {
        if (head == null || head.next == null) {
            return true;
        }
        Node fast = head;
        Node slow = head;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next.next;
        }
        Node n1 = slow;
        Node n2 = n1.next;
        n1.next = null;
        Node n3 = null;
        while (n2 != null) {
            n3 = n2.next;
            n2.next = n1;
            n1 = n2;
            n2 = n3;
        }
        Node last = n1;
        Node r = n1;
        Node l = head;
        boolean ans = true;
        while (r != null && l != null) {
            if (r.value != l.value) {
                ans = false;
                break;
            }
            r = r.next;
            l = l.next;
        }
        n1 = last.next;
        while (n1 != null) {
            n2 = n1.next;
            n1.next = last;
            last = n1;
            n1 = n2;
        }
        return ans;
    }

    public static void main(String[] args) {
        Node head = null;
        head = new Node(0);
        head.next = new Node(1);
        head.next.next = new Node(2);
        head.next.next.next = new Node(3);
        head.next.next.next.next = new Node(4);
        head.next.next.next.next.next = new Node(4);
        head.next.next.next.next.next.next = new Node(3);
        head.next.next.next.next.next.next.next = new Node(2);
        head.next.next.next.next.next.next.next.next = new Node(1);
        head.next.next.next.next.next.next.next.next.next = new Node(0);

        System.out.println(isPalindrome(head));

        System.out.println("=========================");

    }
}

```



### CODE03_给定一个单链表的头节点head，给定一个整数n，将链表按n划分成左边<n、中间==n、右边>n

解题思路：三个区域小中大，每个区域设置一个头指针一个尾指针。从头遍历链表，该值对应一个区域，若区域指针头尾都等于null，那么头尾都等于该值；若区域指针头尾不等于null，那么尾指针指向该值，尾指针等于该值。全部遍历完后，将三个区域的指针头尾相连，注意判断某个区域会不会为空。

```java
public static Node listPartition2(Node head, int pivot) {
		Node sH = null; // small head
		Node sT = null; // small tail
		Node eH = null; // equal head
		Node eT = null; // equal tail
		Node mH = null; // big head
		Node mT = null; // big tail
		Node next = null; // save next node
		// every node distributed to three lists
		while (head != null) {
			next = head.next;
			head.next = null;
			if (head.value < pivot) {
				if (sH == null) {
					sH = head;
					sT = head;
				} else {
					sT.next = head;
					sT = head;
				}
			} else if (head.value == pivot) {
				if (eH == null) {
					eH = head;
					eT = head;
				} else {
					eT.next = head;
					eT = head;
				}
			} else {
				if (mH == null) {
					mH = head;
					mT = head;
				} else {
					mT.next = head;
					mT = head;
				}
			}
			head = next;
		}
		// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头
		if (sT != null) { // 如果有小于区域
			sT.next = eH;
			eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
		}
		// 下一步，一定是需要用eT 去接 大于区域的头
		// 有等于区域，eT -> 等于区域的尾结点
		// 无等于区域，eT -> 小于区域的尾结点
		// eT 尽量不为空的尾巴节点
		if (eT != null) { // 如果小于区域和等于区域，不是都没有
			eT.next = mH;
		}
		return sH != null ? sH : (eH != null ? eH : mH);
	}
```



### CODE04_一种特殊的单链表节点类描述如下 

class Node {
int value; 
Node next; 
Node rand; 
Node(int val) { value = val; } 
} 
rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null
给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制
返回复制的新链表的头节点，要求时间复杂度O(N)，额外空间复杂度O(1) 

解题思路：

先复制节点，插在每个原始结点之后

例子:	7	13	11	10	1

插入:	7	7'	13	13'	11	11'	10	10'	1	1'

先遍历一轮，调整好复制节点的随机指针

再遍历一轮，调整好复制节点的next指针与原始节点的next指针

```java
public static class Node {
        int val;
        Node next;
        Node random;

        Node(int _val) {
            val = _val;
            next = null;
            random = null;
        }
    }

    public static Node copyListWithRandom(Node head) {
        if (head == null) {
            return null;
        }
        Node next = null;
        Node n = head;
        while (n != null) {
            next = n.next;
            Node newNode = new Node(n.val);
            n.next = newNode;
            newNode.next = next;
            n = next;
        }
        Node t = null;
        n = head;
        // 先设置好复制节点的所有随机指针
        while (n != null) {
            t = n.next;
            next = t.next;
            if (n.random != null) {
                t.random = n.random.next;
            } else {
                t.random = null;
            }
            n = next;
        }

        n = head;
        Node ans = head.next;
        while (n != null) {
            t = n.next;
            next = t.next;

            n.next = next;
            if (next != null) {
                t.next = next.next;
            } else {
                t.next = null;
            }
            n = next;
        }
        return ans;
    }
```



# 十、 链表相关面试题（续）、二叉树的常见遍历

内容：

单链表的相交节点系列问题

一种看似高效其实搞笑的节点删除方式

二叉树的中序、先序、后序遍历



题目：

## CODE01_给一个链表，可能有环可能无环，如果无环返回null，如果有环，返回环的入环点

解题思路：

如果允许用容器，那么直接用hashset即可，遍历节点，把每个节点都放入hashset，如果遍历到null，那么说明没环，没有入环点；如果遇到hashset中有重复节点，那么该节点即为入环点。

不允许用容器，快慢指针同时指向开头， 快指针往前走两步，慢指针往前走一步。若快指针走到了null，说明没环，返回null。如果快慢指针相遇了，说明有环，快指针退回开头，快慢指针同时往前一步一步的走，再次相遇的地方即为入环点。

```java
public static Node getLoopNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node fast = head.next.next;
        Node slow = head.next;
        while (fast != slow) {
            if (fast.next == null || fast.next.next == null) {
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
```



题目：

## CODE02_给定两个可能有环也可能无环的单链表，头节点head1和head2，返回相交节点

给定两个可能有环也可能无环的单链表，头节点head1和head2
请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交返回null 
要求如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)

解题思路：

如果允许用容器，同样用hashset，链表1、2都放入hashset，重复的节点为相交点。

如果不用容器，有三种情况，都无环、一个有环一个无环、都有环。

首先用上题判断入环点的方法，判断是哪个情况。

如果都无环，两个指针分别从两个链表头开始往下走，走到最后一个节点（null的前一个），走的同时记录两个链表的长度。若两个指针最后的位置不同，那么无相交。若两个指针最后的位置相同，说明有相交点，相交点在中间的某个位置，两个指针重新回头开始走。对比两个链表的长度，长的链表先走链表长短差值的步数，保证两个指针接下来走到结尾的步数是相同的，两个指针同时开始走，相遇点即为相交点。

如果一个有环一个无环，那么无相交点。

如果两个都有环，那么判断两个链表入环点。若入环点相同，那么说明环在相交点之后，是先相交再入环的，以入环点作为结尾点，重复都无环的操作。若入环点不同，首先让两个指针分别快慢从两个头开始走，若一直不相遇，说明不相交；若相遇了，说明是先入环，在环中相交的，此时相交点就是两个入环点。

```java
public static Node findFirstIntersectNode(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        if (getLoopNode(head1) == null && getLoopNode(head2) == null) {
            return noLoop(head1, head2);
        } else if(getLoopNode(head1)!=null&&getLoopNode(head2)!=null) {
            return bothLoop(head1, getLoopNode(head1), head2, getLoopNode(head2));
        }
        return null;
    }
public static Node getLoopNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }
        Node fast = head.next.next;
        Node slow = head.next;
        while (fast != slow) {
            if (fast.next == null || fast.next.next == null) {
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

    private static Node noLoop(Node head1, Node head2) {
        int n = 0;
        Node n1 = head1;
        Node n2 = head2;
        while (n1.next != null) {
            n1 = n1.next;
            n--;
        }
        while (n2.next != null) {
            n2 = n2.next;
            n++;
        }
        if(n1!=n2){
            return null;
        }
        n1 = n > 0 ? head2 : head1;
        n2 = n1 == head1 ? head2 : head1;
        n = Math.abs(n);
        while(n!=0){
            n1=n1.next;
            n--;
        }
        while (n1 != n2) {
            n1 = n1.next;
            n2 = n2.next;
        }
        return n1;
    }
```



 

   

## CODE03_能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？



二叉树先序、中序、后序的递归遍历和递归序  



二叉树先序、中序、后序的非递归遍历

先序：

1.将头节点放进栈中，开始循环，直到栈空

2.每次循环先pop，输出，有右入右，有左入左

后序：

1.将头节点放进栈中，开始循环，直到栈空

2.每次循环先pop，放入另外一个栈，有左入左，有右入右

3.另外一个栈从头到尾输出

中序：

1.当前节点cur指向头节点，开始循环，直到cur指向null或栈为空

2.如果cur不是空，那么进栈，cur指向cur的左孩子，直到cur为空

3.如果cur为空，那么cur指向栈顶pop，输出cur，cur再指向cur的右孩子



# 十一、 二叉树常见面试题和二叉树的递归套路（上）



能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？



内容：

通过题目来熟悉二叉树的解题技巧

题目：

二叉树的按层遍历

1.用队列实现，cur先指向头节点，直接打印

2.有左入左，有右入右



二叉树的序列化和反序列化

二叉树->字符串——序列化

字符串->二叉树——反序列化



N叉树如何通过二叉树来序列化、并完成反序列化
Leetcode题目：https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/



打印二叉树的函数设计



求二叉树的最大宽度



求二叉树某个节点的后继节点
二叉树结构如下定义：
Class Node {
	V value;
	Node left;
	Node right;
	Node parent;
}
给你二叉树中的某个节点，返回该节点的后继节点 



折纸问题
请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开
此时折痕是凹下去的，即折痕突起的方向指向纸条的背面
如果从纸条的下边向上方连续对折2次，压出折痕后展开
此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 
给定一个输入参数N，代表纸条都从下边向上方连续对折N次
请从上到下打印所有折痕的方向。 
N=1时，打印: down 
N=2时，打印: down down up 



12 二叉树常见面试题和二叉树的递归套路（中）

内容：

通过题目来熟悉二叉树的解题技巧

介绍二叉树的递归套路
1）假设以X节点为头，假设可以向X左树和X右树要任何信息
2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
5）递归函数都返回S，每一棵子树都这么要求
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

题目：

判断二叉树是不是搜索二叉树

判断二叉树是不是平衡二叉树

判断二叉树是不是满二叉树

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小

给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离



13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法

内容：

二叉树递归套路继续实践

一道贪心算法从头到尾的完整做法

解决贪心题目的重要技巧，即对数器来验证脑洞

再次强调对数器的重要性

题目：

判断二叉树是不是完全二叉树（一般方法解决、递归套路解决）

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点

给定一棵二叉树的头节点head，和另外两个节点a和b，返回a和b的最低公共祖先

派对的最大快乐值
 员工信息的定义如下:
class Employee {
    public int happy; // 这名员工可以带来的快乐值
    List<Employee> subordinates; // 这名员工有哪些直接下级
}
公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树
树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级
叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外每个员工都有一个或多个直接下级
这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：
1.如果某个员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。

给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中字典序最小的结果



14 贪心算法（续）、并查集

内容：

贪心算法继续实战

并查集详解

题目：

给定一个字符串str，只由'X'和'.'两种字符构成
'X'表示墙，不能放灯，也不需要点亮；'.'表示居民点，可以放灯，需要点亮
如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮
返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

一块金条切成两半，是需要花费和长度数值一样的铜板
比如长度为20的金条，不管怎么切都要花费20个铜板，一群人想整分整块金条，怎么分最省铜板? 
例如，给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。
如果先把长度60的金条分成10和50，花费60；再把长度50的金条分成20和30，花费50；一共花费110铜板
但如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20，花费30；一共花费90铜板
输入一个数组，返回分割的最小代价

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间
你来安排宣讲的日程，要求会议室进行的宣讲的场次最多，返回最多的宣讲场次

输入正数数组costs、正数数组profits、正数K和正数M
costs[i]表示i号项目的花费
profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)
K表示你只能串行的最多做k个项目
M表示你初始的资金
说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目，不能并行的做项目。
输出：最后获得的最大钱数

并查集的实现



15 并查集相关的常见面试题

内容：

通过解答实际出现的面试题来体会并查集的优势、熟悉并查集的使用

题目：

一群朋友中，有几个不相交的朋友圈
Leetcode题目：https://leetcode.com/problems/friend-circles/

岛问题（递归解法 + 并查集解法 + 并行解法）
给定一个二维数组matrix，里面的值不是1就是0，上、下、左、右相邻的1认为是一片岛，返回matrix中岛的数量



16 图及其与图相关的算法

内容：

图的表达方式

图的常见描述

图的宽度优先遍历

图的深度优先遍历

图的拓扑排序

最小生成树算法Kruskal

最小生成树算法Prim

单元最短路径算法Dijkstra

题目：

图的数据结构抽象

实现图的宽度优先遍历

实现图的深度优先遍历

三种方式实现图的拓扑排序

用并查集实现Kruskal算法

用堆实现Prim算法

实现Dijkstra算法，用加强堆做更好的实现（16节+17节一开始）



17 用加强堆更好的实现Dijkstra算法、常见的递归

内容：

加强堆实现Dijkstra算法

递归的设计

常见的递归

题目：

打印n层汉诺塔从最左边移动到最右边的全部过程（递归+非递归实现）

打印一个字符串的全部子序列

打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

打印一个字符串的全部排列

打印一个字符串的全部排列，要求不要出现重复的排列

给定一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数



18 暴力递归到动态规划（一）

内容：

讲述暴力递归和动态规划的关系

记忆化搜索

动态规划都可以由暴力递归改进过来，解决动态规划的套路

常见的尝试模型

设计尝试过程的原则

本节是暴力递归到动态规划的总纲（很重要）

后续的课都是在讲述这一系列的套路

题目：

假设有排成一行的N个位置记为1~N，N一定大于或等于2
开始时机器人在其中的M位置上(M一定是1~N中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到N-1位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数

给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数



19 暴力递归到动态规划（二）

内容：

以18节为总纲

背包问题

记忆化搜索的一个很重要的注意点

通过面试题进一步强化动态规划的解题套路

题目：

背包问题
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量
返回能装下的最大价值

规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  abcd + abcd 2  abcd+ba 2
所以返回2

给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度
比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6



20 暴力递归到动态规划（三）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

题目：

给定一个字符串str，返回这个字符串的最长回文子序列长度
比如 ： str = “a12b3c43def2ghi1kpm”
最长回文子序列是“1234321”或者“123c321”，返回长度7

请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 

给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
假设所有人拿到咖啡之后立刻喝干净，
返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b



21 暴力递归到动态规划（四）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

题目：

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角
沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和
返回最小距离累加和

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
即便是值相同的货币也认为每一张都是不同的，
返回组成aim的方法数
例如：arr = {1,1,1}，aim = 2
第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2
一共就3种方法，所以返回3

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的方法数
例如：arr = {1,2}，aim = 4
方法如下：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
认为值相同的货币没有任何不同，
返回组成aim的方法数
例如：arr = {1,2,1,1,2,1,2}，aim = 4
方法：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

给定5个参数，N，M，row，col，k
表示在N*M的区域上，醉汉Bob初始在(row,col)位置
Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位
任何时候Bob只要离开N*M的区域，就直接死亡
返回k步之后，Bob还在N*M的区域的概率



22 暴力递归到动态规划（五）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

斜率优化技巧

题目：

给定3个参数，N，M，K
怪兽有N滴血，等着英雄来砍自己
英雄每一次打击，都会让怪兽流失[0~M]的血量
到底流失多少？每一次在[0~M]上等概率的获得一个值
求K次打击之后，英雄把怪兽砍死的概率

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的最少货币数

给定一个正数n，求n的裂开方法数，
规定：后面的数不能比前面的数小
比如4的裂开方法有：
1+1+1+1、1+1+2、1+3、2+2、4
5种，所以返回5



23 暴力递归到动态规划（六）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

位信息技巧

题目：

给定一个正数数组arr，
请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和

给定一个正数数组arr，请把arr中所有的数分成两个集合
如果arr长度为偶数，两个集合包含数的个数要一样多
如果arr长度为奇数，两个集合包含数的个数必须只差一个
请尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和

N皇后问题是指在N*N的棋盘上要摆N个皇后，
要求任何两个皇后不同行、不同列， 也不在同一条斜线上
给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92



24 窗口内最大值或最小值的更新结构

内容：

滑动窗口

窗口内最大值或最小值的更新结构

用题目来学习窗口内最大值或最小值的更新结构提供的便利性

题目：

窗口内最大值或最小值更新结构的实现
假设一个固定大小为W的窗口，依次划过arr，
返回每一次滑出状况的最大值
例如，arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]

给定一个整型数组arr，和一个整数num
某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
返回arr中达标子数组的数量

加油站的良好出发点问题

动态规划中利用窗口内最大值或最小值更新结构做优化（难）
arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
返回组成aim的最少货币数
注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了



25 单调栈

内容：

单调栈的原理（无重复数+有重复数）

用题目来学习单调栈提供的便利性

题目：

单调栈实现（无重复数+有重复数）

给定一个只包含正数的数组arr，arr中任何一个子数组sub，
一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
那么所有子数组中，这个值最大是多少？

给定一个非负数组arr，代表直方图，返回直方图的最大长方形面积

给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的最大子矩形内部有多少个1（面积）

给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的子矩形数量



26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型

内容：

再讲一个单调栈相关的面试题

斐波那契数列的矩阵快速幂模型详解

题目：

给定一个数组arr，返回所有子数组最小值的累加和

斐波那契数列矩阵乘法方式的实现

台阶方法数问题
一个人可以一次往上迈1个台阶，也可以迈2个台阶，返回迈上N级台阶的方法数

奶牛生小牛问题
第一年农场有1只成熟的母牛A，往后的每年：
1）每一只成熟的母牛都会生一只母牛
2）每一只新出生的母牛都在出生的第三年成熟
3）每一只母牛永远不会死
返回N年后牛的数量

给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串
如果某个字符串，任何0字符的左边都有1紧挨着，认为这个字符串达标
返回有多少达标的字符串

用1*2的瓷砖，把N*2的区域填满，返回铺瓷砖的方法数



27 KMP算法

内容：

KMP算法

和KMP算法相关的面试题

题目：

KMP算法实现

给定两棵二叉树的头节点head1和head2，返回head1中是否有某个子树的结构和head2完全一样

判断str1和str2是否互为旋转字符串



28 Manacher算法

内容：

Manacher算法

和Manacher算法相关的面试题

题目：

Manacher算法实现

给定一个字符串str，只能在str的后面添加字符，想让str整体变成回文串，返回至少要添加几个字符



29 在无序数组中找到第K小的数、蓄水池算法

内容：

时间复杂度O(N)可以解决在无序数组中找到第K小的数，这个经典的面试题

改写快排的partition方法

bfprt算法

蓄水池算法

题目：

在无序数组中找到第K小的数（改写快排+bfprt）

设计在无序数组中收集最大的前K个数字的算法（根据不同的三个时间复杂度，设计三个算法）
给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数
不同时间复杂度三个方法：
1）O(N*logN)
2）O(N + K*logN)
3）O(n + k*logk)

蓄水池算法实现
假设有一个源源吐出不同球的机器，
只有装下10个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉
如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里




30 二叉树的Morris遍历

内容：

二叉树之前的遍历方式有空间浪费的问题

Morris遍历时间复杂度O(N)，额外空间复杂度O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的

假设来到当前节点cur，开始时cur来到头节点位置
1）如果cur没有左孩子，cur向右移动(cur = cur.right)
2）如果cur有左孩子，找到左子树上最右的节点mostRight：
	a.如果mostRight的右指针指向空，让其指向cur，
	然后cur向左移动(cur = cur.left)
	b.如果mostRight的右指针指向cur，让其指向null，
	然后cur向右移动(cur = cur.right)
3）cur为空时遍历停止

Morris遍历实现二叉树的先序、中序、后序遍历

题目：

Morris遍历的实现

给定一棵二叉树的头节点head，求以head为头的树中，最小深度是多少？



31 线段树

内容：

线段树是一种支持范围整体修改和范围整体查询的数据结构

线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况

题目：

给定一个数组arr，用户希望你实现如下三个方法
1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V
2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V
3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和
怎么让这三个方法，时间复杂度都是O(logN)

想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线
下面是这个游戏的简化版：
1）只会下落正方形积木
2）[a,b] -> 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落
3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的
4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。
给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，
返回每一次掉落之后的最大高度
Leetcode题目：https://leetcode.com/problems/falling-squares/



32 IndexTree、AC自动机

内容：

IndexTree
1）支持区间查询
2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构
3）只支持单点更新

AC自动机
解决在一个大字符串中，找到多个候选字符串的问题
1）把所有匹配串生成一棵前缀树
2）前缀树节点增加fail指针
3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀
   拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点（迷不迷？听讲述！）

题目：

IndexTree在一维数组和二维数组上的实现

AC自动机的实现



33 与哈希函数有关的结构

内容：

哈希函数

哈希函数的应用

布隆过滤器

一致性哈希

题目：

原理讲述为主，面试只会聊设计，所以本节无题目



34 资源限制类题目的解题套路

内容：

布隆过滤器用于集合的建立与查询，并可以节省大量空间
一致性哈希解决数据服务器的负载管理问题
利用并查集结构做岛问题的并行计算
哈希函数可以把数据按照种类均匀分流
位图解决某一范围上数字的出现情况，并可以节省大量空间
利用分段统计思想、并进一步节省大量空间
利用堆、外排序来做多个处理单元的结果合并

题目：

32位无符号整数的范围是0~4,294,967,295，
现在有一个正好包含40亿个无符号整数的文件，
可以使用最多1GB的内存，怎么找到出现次数最多的数？

32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，
所以在整个范围中必然存在没出现过的数，可以使用最多1GB的内存，怎么找到所有未出现过的数？
进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可

有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
补充：某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的中位数？

32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，
整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果



35 有序表（上）

内容：

平衡搜索二叉树

左旋

右旋

AVL树的节点违规4种类型（LL，LR，RL，RR）

题目：

AVL树的实现



36 有序表（中）

内容：

size-balanced-tree详解

skiplist详解

聊聊红黑树

题目：

size-balanced-tree实现

skiplist实现



37 有序表（下）

内容：

讲解有序表相关的面试题

讲解改写有序表的题目核心点

题目：

给定一个数组arr，和两个整数a和b（a<=b）。求arr中有多少个子数组，累加和在[a,b]这个范围上。返回达标的子数组数量

有一个滑动窗口：
1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
2）任何一步都可能R往右动，表示某个数进了窗口
3）任何一步都可能L往右动，表示某个数出了窗口
想知道每一个窗口状态的中位数

设计一个结构包含如下两个方法：
void add(int index, int num)：把num加入到index位置
int get(int index) ：取出index位置的值
void remove(int index) ：把index位置上的值删除
要求三个方法时间复杂度O(logN)

假设有打乱顺序的一群人站成一个队列，数组people表示队列中一些人的属性（不一定按顺序）
每个people[i]=[hi, ki]表示第i个人的身高为hi，前面正好有ki个身高大于或等于hi的人
请你重新构造并返回输入数组people所表示的队列，返回的队列应该格式化为数组queue
其中queue[j]=[hj, kj]是队列中第j个人的属性（queue[0] 是排在队列前面的人）。
Leetcode题目：https://leetcode.com/problems/queue-reconstruction-by-height/



38 根据对数器找规律、根据数据量猜解法

内容：

讲解对数器找规律的解题技巧

讲解根据数据量猜解法的技巧
1）C/C++，1秒处理的指令条数为10的8次方
2）Java等语言，1~4秒处理的指令条数为10的8次方
3）这里就有大量的分析提示了


题目：

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量
1）能装下6个苹果的袋子
2）能装下8个苹果的袋子
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，
且使用的每个袋子必须装满，给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

给定一个正整数N，表示有N份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草
不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4的某次方)
谁最先把草吃完，谁获胜，假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数N，返回谁会赢

定义一种数：可以表示成若干（数量>1）连续正数和的数
比如，5=2+3，5就是这样的数；12=3+4+5，12就是这样的数
2=1+1，2不是这样的数，因为等号右边不是连续正数
给定一个参数N，返回是不是可以表示成若干连续正数和的数

int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你
他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力
你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你
他的能力直接累加到你的能力上
返回通过所有的怪兽，需要花的最小钱数
（课上会给出不同的数据量描述）



39 根据数据量猜解法（续）、分治技巧、卡特兰数

内容：

继续熟悉根据数据量猜解法

讲解分治法

讲解卡特兰数（课上证明的时候有小错，在40节开始处修正了）

题目：

给定一个非负数组arr，和一个正数m，返回arr的所有子序列中累加和%m之后的最大值

牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w，牛牛想知道在总体积不超过背包容量的情况下,
一共有多少种零食放法，体积为0也算一种放法
1 <= n <= 30, 1 <= w <= 2 * 10^9，v[I] (0 <= v[i] <= 10^9）

假设给你N个0，和N个1，你必须用全部数字拼序列，返回有多少个序列满足任何前缀串，1的数量都不少于0的数量

有N个二叉树节点，每个节点彼此之间无任何差别，返回由N个二叉树节点，组成的不同结构数量是多少？

题目补充：	arr中的值可能为正，可能为负，可能为0，自由选择arr中的数字，能不能累加得到sum（多种做法）



40 子数组达到规定累加和的最大长度系列问题、矩阵处理技巧题

内容：

修正了39节卡特兰数讲解时的一个小错误

熟悉子数组达到规定累加和的三个模型（正、有正有负有0、累加和<=K）

矩阵处理技巧的宏观调度coding技巧

题目：

给定一个正整数组成的无序数组arr，给定一个正整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K
并且是长度最大的，返回其长度

给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的，返回其长度

给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度

给定一个正方形矩阵matrix，原地调整成顺时针90度转动的样子

给定一个正方形或者长方形矩阵matrix，实现转圈打印

给定一个正方形或者长方形矩阵matrix，实现zigzag打印

转圈打印星号*问题



41 四边形不等式技巧（上）

内容：

区间划分问题中的划分点不回退现象

四边形不等式技巧特征
1，两个可变参数的区间划分问题
2，每个格子有枚举行为
3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
4，而且两组单调关系是反向的：(升 升，降 降)  (升 降，降 升)
5，能否获得指导枚举优化的位置对：上+右，或者，左+下

四边形不等式技巧注意点
1，不要证明！用对数器验证！
2，枚举的时候面对最优答案相等的时候怎么处理？用对数器都试试！
3，可以把时间复杂度降低一阶
O(N^3) -> O(N^2)
O(N^2 * M) -> O(N * M) 
O(N * M^2) -> O(N * M) 
4，四边形不等式有些时候是最优解，有些时候不是
不是的原因：尝试思路，在根儿上不够好

题目：

给定一个非负数组arr，长度为N，
那么有N-1种方案可以把arr切成左右两部分
每一种方案都有，min{左部分累加和，右部分累加和}
求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？
整个过程要求时间复杂度O(N)

把题目一中提到的，min{左部分累加和，右部分累加和}，定义为S(N-1)，也就是说：
S(N-1)：在arr[0…N-1]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
现在要求返回一个长度为N的s数组，
s[i] =在arr[0…i]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
得到整个s数组的过程，做到时间复杂度O(N)

摆放着n堆石子。现要将石子有次序地合并成一堆，规定每次只能选相邻的2堆石子合并成新的一堆
并将新的一堆石子数记为该次合并的得分，求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案

给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数num
表示画匠的数量，每个画匠只能画连在一起的画作
所有的画家并行工作，返回完成所有的画作需要的最少时间
arr=[3,1,4]，num=2。
最好的分配方式为第一个画匠画3和1，所需时间为4
第二个画匠画4，所需时间为4
所以返回4
arr=[1,1,1,4,3]，num=3
最好的分配方式为第一个画匠画前三个1，所需时间为3
第二个画匠画4，所需时间为4
第三个画匠画3，所需时间为3
返回4



42 四边形不等式技巧（下）

内容：

继续熟悉四边形不等式

展示好的尝试是最关键的

题目：

一条直线上有居民点，邮局只能建在居民点上
给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量
选择num个居民点建立num个邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离
arr=[1,2,3,4,5,1000]，num=2
第一个邮局建立在3位置，第二个邮局建立在1000位置
那么1位置到邮局的距离为2，2位置到邮局距离为1，3位置到邮局的距离为0，4位置到邮局的距离为1，5位置到邮局的距离为2
1000位置到邮局的距离为0
这种方案下的总距离为6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回6

一座大楼有0~N层，地面算作第0层，最高的一层为第N层
已知棋子从第0层掉落肯定不会摔碎，从第i层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)
给定整数N作为楼层数，再给定整数K作为棋子数
返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数
一次只能扔一个棋子
N=10，K=1
返回10
因为只有1棵棋子，所以不得不从第1层开始一直试到第10层
在最差的情况下，即第10层是不会摔坏的最高层，最少也要扔10次
N=3，K=2
返回2
先在2层扔1棵棋子，如果碎了试第1层，如果没碎试第3层
N=105，K=2
返回14
第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13
若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26
若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试28~38
若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49
若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试51~59
若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试61~68
若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试70~76
若没碎，第一个棋子继续在84层扔，碎了则用仅存的一个棋子试78~83
若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试85~89
若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试91~94
若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试96~98
若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101
若没碎，第一个棋子继续在104层扔，碎了则用仅存的一个棋子试103
若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果



43 状态压缩的动态规划

内容：

动态规划的状态压缩技巧

题目：

在"100 game"这个游戏中，两名玩家轮流选择从1到10的任意整数，累计整数和
先使得累计整数和达到或超过100的玩家，即为胜者，如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？
例如，两个玩家可以轮流从公共整数池中抽取从1到15的整数（不放回），直到累计整数和 >= 100
给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和）
判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）
你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。
Leetcode题目：https://leetcode.com/problems/can-i-win/

TSP问题
有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0
所有点到点的距离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示
现要求一旅行商从k城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城
参数给定一个matrix，给定k。返回总距离最短的路的距离

铺砖问题（最优解其实是轮廓线dp，但是这个解法对大厂刷题来说比较难，掌握课上的解法即可）
你有无限的1*2的砖块，要铺满M*N的区域，
不同的铺法有多少种?



44 DC3生成后缀数组详解

内容：

后缀数组

介绍用DC3算法生成后缀数组的流程

题目：

给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串
Leetcode题目：https://leetcode.com/problems/last-substring-in-lexicographical-order/

DC3算法的实现（完全根据论文描述）



45 后缀数组解决的面试题

内容：

通过题目进一步熟悉DC3算法

通过DC3算法得到height数组

题目：

给定两个字符串str1和str2，想把str2整体插入到str1中的某个位置，形成最大的字典序，返回字典序最大的结果

给两个长度分别为M和N的整型数组nums1和nums2，其中每个值都不大于9，再给定一个正数K。 你可以在nums1和nums2中挑选数字，要求一共挑选K个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果

最长公共子串问题是面试常见题目之一，假设str1长度N，str2长度M
一般在面试场上回答出O(N*M)的解法已经是比较优秀了
因为得到O(N*M)的解法，就已经需要用到动态规划了
但其实这个问题的最优解是O(N+M)，需要用到后缀数组+height数组
课上将对本题解法代码进行详解



46 动态规划猜法中和外部信息简化的相关问题（上）、哈夫曼树

内容：

以18节做总纲

有些动态规划面试题，需要很好的设计参数，这种设计方式都有"外部信息简化"的特征

哈夫曼树

题目：

有n个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中
现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1] 枚硬币
这里的i-1和i+1代表和i相邻的、没有被戳爆的！两个气球的序号
如果i-1或i+1超出了数组的边界，那么就当它是一个数字为1的气球
求所能获得硬币的最大数量
Leetcode题目：https://leetcode.com/problems/burst-balloons/

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色，你将经过若干轮操作去去掉盒子
直到所有的盒子都去掉为止，每一轮你可以移除具有相同颜色的连续k个盒子（k >= 1）
这样一轮之后你将得到 k * k 个积分，当你将所有盒子都去掉之后，求你能获得的最大积分和
Leetcode题目：https://leetcode.com/problems/remove-boxes/

如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉
比如:"ab"，其中a和b都不能被消掉
如果一个字符相邻的位置有相同字符，就可以一起消掉
比如:"abbbc"，中间一串的b是可以被消掉的，消除之后剩下"ac"
某些字符如果消掉了，剩下的字符认为重新靠在一起
给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量
比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1
但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。
再比如："baaccabb"，
如果先消除最左侧的两个a，剩下"bccabb"，如果再消除最左侧的两个c，剩下"babb"，最后消除最右侧的两个b，剩下"ba"无法再消除，返回2
而最优策略是：
如果先消除中间的两个c，剩下"baaabb"，如果再消除中间的三个a，剩下"bbb"，最后消除三个b，不留下任何字符，返回0，这才是最优解

给定一个数组arr，和一个正数M，返回在arr的子数组在长度不超过M的情况下，最大的累加和

哈夫曼树的实现



47 动态规划猜法中和外部信息简化的相关问题（下）、最大网络流算法之Dinic算法

内容：

进一步解决带有"外部信息简化"特征的动态规划

Dinic算法

题目：

有台奇怪的打印机有以下两个特殊要求：
打印机每次只能打印由同一个字符组成的序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串s，你的任务是计算这个打印机打印它需要的最少打印次数。
Leetcode题目：https://leetcode.com/problems/strange-printer/

整型数组arr长度为n(3 <= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件：
1. 0位置的要求：arr[0]<=arr[1] 
2. n-1位置的要求：arr[n-1]<=arr[n-2]
3. 中间i位置的要求：arr[i]<=max(arr[i-1],arr[i+1]) 
但是在arr有些数字丢失了，比如k位置的数字之前是正数，丢失之后k位置的数字为0
请你根据上述条件，计算可能有多少种不同的arr可以满足以上条件
比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1，即[6,9,9]达标

Dinic算法详解
测试链接：https://lightoj.com/problem/internet-bandwidth

